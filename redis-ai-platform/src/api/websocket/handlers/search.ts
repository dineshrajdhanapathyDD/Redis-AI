import { APIServices } from '@/api/rest';
import { APIServices } from '@/api/rest';
import logger from '@/utils/logger';
import { Redis } from 'ioredis';\nimport { logger } from '../../../utils/logger';\nimport { APIServices } from '../../rest/index';\nimport { SocketSession } from '../index';\n\nexport class SearchHandler {\n  private io: any;\n  private services: APIServices;\n  private redis: Redis;\n  private readonly SEARCH_ROOM_PREFIX = 'search:';\n\n  constructor(io: any, redis: Redis, services: APIServices) {\n    this.io = io;\n    this.services = services;\n    this.redis = redis;\n  }\n\n  public setupHandlers(socket: any, connectionInfo: any): void {\n    // Search query handler\n    socket.on('search:query', (data: {\n      query: string;\n      type?: string;\n      filters?: any;\n      limit?: number;\n    }) => this.handleSearchQuery(socket, data));\n\n    // Search suggestions handler\n    socket.on('search:suggestions', (data: {\n      partial: string;\n      context?: any;\n      limit?: number;\n    }) => this.handleSearchSuggestions(socket, data));\n\n    // Subscribe to search updates\n    socket.on('search:subscribe', (data: {\n      searchId?: string;\n      userId?: string;\n    }) => this.handleSubscribeToSearchUpdates(socket, data));\n\n    // Unsubscribe from search updates\n    socket.on('search:unsubscribe', (data: {\n      searchId?: string;\n      userId?: string;\n    }) => this.handleUnsubscribeFromSearchUpdates(socket, data));\n\n    // Get search history\n    socket.on('search:history', (data: {\n      limit?: number;\n      offset?: number;\n    }) => this.handleGetSearchHistory(socket, data));\n  }\n\n  async handleSearchQuery(socket: any, data: {\n    query: string;\n    type?: string;\n    filters?: any;\n    limit?: number;\n  }): Promise<void> {\n    try {\n      const { query, type = 'multi-modal', filters = {}, limit = 20 } = data;\n      const userId = socket.data.user?.id || 'anonymous';\n      \n      const searchRequest = {\n        id: `search_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        query,\n        type,\n        filters,\n        limit,\n        userId,\n        timestamp: Date.now()\n      };\n\n      // Perform search using the search service\n      const results = await this.services.searchService.multiModalSearch.search({\n        query,\n        contentTypes: type === 'multi-modal' ? ['text', 'image', 'audio', 'code'] : [type],\n        limit,\n        filters\n      });\n      \n      // Send results back to client\n      socket.emit('search:results', {\n        searchId: searchRequest.id,\n        query,\n        results: results.map(result => ({\n          id: result.id,\n          type: result.type,\n          content: result.content,\n          score: result.score,\n          metadata: result.metadata\n        })),\n        totalResults: results.length,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Store search for analytics\n      await this.redis.lpush(\n        `search_history:${userId}`,\n        JSON.stringify(searchRequest)\n      );\n      \n      // Keep only recent searches (last 100)\n      await this.redis.ltrim(`search_history:${userId}`, 0, 99);\n      \n      logger.info(`Search performed by user ${userId}: \"${query}\" (${results.length} results)`);\n\n    } catch (error) {\n      logger.error('Handle search query error:', error);\n      socket.emit('search:error', {\n        type: 'search_failed',\n        message: 'Failed to perform search',\n        error: error.message\n      });\n    }\n  }\n\n  async handleSearchSuggestions(socket: any, data: {\n    partial: string;\n    context?: any;\n    limit?: number;\n  }): Promise<void> {\n    try {\n      const { partial, context = {}, limit = 10 } = data;\n      const userId = socket.data.user?.id || 'anonymous';\n      \n      // Get search suggestions based on partial input\n      const suggestions = await this.generateSearchSuggestions(\n        userId,\n        partial,\n        context,\n        limit\n      );\n      \n      // Send suggestions back to client\n      socket.emit('search:suggestions', {\n        partial,\n        suggestions: suggestions.map(suggestion => ({\n          text: suggestion.text,\n          type: suggestion.type,\n          score: suggestion.score,\n          metadata: suggestion.metadata\n        })),\n        timestamp: new Date().toISOString()\n      });\n      \n      logger.info(`Search suggestions generated for user ${userId}: \"${partial}\" (${suggestions.length} suggestions)`);\n\n    } catch (error) {\n      logger.error('Handle search suggestions error:', error);\n      socket.emit('search:error', {\n        type: 'suggestions_failed',\n        message: 'Failed to generate suggestions',\n        error: error.message\n      });\n    }\n  }\n\n  async handleSubscribeToSearchUpdates(socket: any, data: {\n    searchId?: string;\n    userId?: string;\n  }): Promise<void> {\n    try {\n      const { searchId, userId: targetUserId } = data;\n      const userId = socket.data.user?.id || 'anonymous';\n      \n      let roomName: string;\n      \n      if (searchId) {\n        // Subscribe to specific search updates\n        roomName = `${this.SEARCH_ROOM_PREFIX}${searchId}`;\n      } else if (targetUserId && targetUserId === userId) {\n        // Subscribe to user's search updates\n        roomName = `${this.SEARCH_ROOM_PREFIX}user:${userId}`;\n      } else {\n        socket.emit('search:error', {\n          type: 'invalid_subscription',\n          message: 'Invalid subscription parameters'\n        });\n        return;\n      }\n      \n      await socket.join(roomName);\n      \n      socket.emit('search:subscribed', {\n        room: roomName,\n        timestamp: new Date().toISOString()\n      });\n      \n      logger.info(`Socket ${socket.id} subscribed to search updates: ${roomName}`);\n\n    } catch (error) {\n      logger.error('Handle subscribe to search updates error:', error);\n    }\n  }\n\n  async handleUnsubscribeFromSearchUpdates(socket: any, data: {\n    searchId?: string;\n    userId?: string;\n  }): Promise<void> {\n    try {\n      const { searchId, userId: targetUserId } = data;\n      const userId = socket.data.user?.id || 'anonymous';\n      \n      let roomName: string;\n      \n      if (searchId) {\n        roomName = `${this.SEARCH_ROOM_PREFIX}${searchId}`;\n      } else if (targetUserId && targetUserId === userId) {\n        roomName = `${this.SEARCH_ROOM_PREFIX}user:${userId}`;\n      } else {\n        return;\n      }\n      \n      await socket.leave(roomName);\n      \n      socket.emit('search:unsubscribed', {\n        room: roomName,\n        timestamp: new Date().toISOString()\n      });\n      \n      logger.info(`Socket ${socket.id} unsubscribed from search updates: ${roomName}`);\n\n    } catch (error) {\n      logger.error('Handle unsubscribe from search updates error:', error);\n    }\n  }\n\n  async handleGetSearchHistory(socket: any, data: {\n    limit?: number;\n    offset?: number;\n  }): Promise<void> {\n    try {\n      const { limit = 20, offset = 0 } = data;\n      const userId = socket.data.user?.id || 'anonymous';\n      \n      // Get search history from Redis\n      const history = await this.redis.lrange(\n        `search_history:${userId}`,\n        offset,\n        offset + limit - 1\n      );\n      \n      const searchHistory = history.map(h => JSON.parse(h));\n      \n      socket.emit('search:history', {\n        history: searchHistory.map(search => ({\n          id: search.id,\n          query: search.query,\n          type: search.type,\n          timestamp: search.timestamp\n        })),\n        total: await this.redis.llen(`search_history:${userId}`),\n        limit,\n        offset,\n        timestamp: new Date().toISOString()\n      });\n      \n      logger.info(`Search history retrieved for user ${userId}: ${searchHistory.length} items`);\n\n    } catch (error) {\n      logger.error('Handle get search history error:', error);\n      socket.emit('search:error', {\n        type: 'history_failed',\n        message: 'Failed to retrieve search history',\n        error: error.message\n      });\n    }\n  }\n\n  async handleDisconnection(socket: any, session: SocketSession): Promise<void> {\n    try {\n      const userId = session.userId;\n      \n      // Clean up any search-related subscriptions\n      for (const room of session.rooms) {\n        if (room.startsWith(this.SEARCH_ROOM_PREFIX)) {\n          await socket.leave(room);\n        }\n      }\n      \n      logger.info(`Search handler cleanup for user ${userId}`);\n\n    } catch (error) {\n      logger.error('Handle search disconnection error:', error);\n    }\n  }\n\n  private async generateSearchSuggestions(\n    userId: string,\n    partial: string,\n    context: any,\n    limit: number\n  ): Promise<any[]> {\n    try {\n      // Get user's search history for personalized suggestions\n      const recentSearches = await this.redis.lrange(`search_history:${userId}`, 0, 19);\n      const searchHistory = recentSearches.map(s => JSON.parse(s));\n      \n      // Generate suggestions based on:\n      // 1. Partial text matching from history\n      // 2. Popular searches\n      // 3. Context-aware suggestions\n      \n      const suggestions: any[] = [];\n      \n      // History-based suggestions\n      const historySuggestions = searchHistory\n        .filter(search => search.query.toLowerCase().includes(partial.toLowerCase()))\n        .map(search => ({\n          text: search.query,\n          type: 'history',\n          score: 0.8,\n          metadata: { lastUsed: search.timestamp }\n        }))\n        .slice(0, Math.floor(limit / 2));\n      \n      suggestions.push(...historySuggestions);\n      \n      // Popular searches (mock implementation)\n      const popularSuggestions = [\n        { text: `${partial} tutorial`, type: 'popular', score: 0.6, metadata: {} },\n        { text: `${partial} examples`, type: 'popular', score: 0.6, metadata: {} },\n        { text: `${partial} documentation`, type: 'popular', score: 0.5, metadata: {} }\n      ].filter(s => s.text.length > partial.length)\n        .slice(0, limit - suggestions.length);\n      \n      suggestions.push(...popularSuggestions);\n      \n      // Sort by score and return top suggestions\n      return suggestions\n        .sort((a, b) => b.score - a.score)\n        .slice(0, limit);\n      \n    } catch (error) {\n      logger.error('Generate search suggestions error:', error);\n      return [];\n    }\n  }\n\n  // Public methods for external use\n  public async broadcastSearchUpdate(\n    searchId: string,\n    update: any\n  ): Promise<void> {\n    try {\n      await this.redis.publish(\n        `search_updates:${searchId}`,\n        JSON.stringify({\n          type: 'search_updated',\n          searchId,\n          update,\n          timestamp: new Date().toISOString()\n        })\n      );\n    } catch (error) {\n      logger.error('Broadcast search update error:', error);\n    }\n  }\n\n  public async broadcastUserSearchUpdate(\n    userId: string,\n    update: any\n  ): Promise<void> {\n    try {\n      await this.redis.publish(\n        `search_updates:user:${userId}`,\n        JSON.stringify({\n          type: 'user_search_updated',\n          userId,\n          update,\n          timestamp: new Date().toISOString()\n        })\n      );\n    } catch (error) {\n      logger.error('Broadcast user search update error:', error);\n    }\n  }\n\n  public async getUserSearchHistory(userId: string, limit: number = 50): Promise<any[]> {\n    try {\n      const history = await this.redis.lrange(`search_history:${userId}`, 0, limit - 1);\n      return history.map(h => JSON.parse(h));\n    } catch (error) {\n      logger.error('Get user search history error:', error);\n      return [];\n    }\n  }\n}"