export interface SystemMetrics {\n  timestamp: number;\n  cpu: {\n    usage: number; // percentage\n    loadAverage: number[];\n    cores: number;\n  };\n  memory: {\n    used: number; // bytes\n    total: number; // bytes\n    free: number; // bytes\n    percentage: number;\n  };\n  redis: {\n    connected: boolean;\n    memory: number; // bytes\n    operations: number; // ops/sec\n    connections: number;\n    hitRate: number; // percentage\n    keyCount: number;\n  };\n  network: {\n    bytesIn: number;\n    bytesOut: number;\n    packetsIn: number;\n    packetsOut: number;\n  };\n  application: {\n    uptime: number; // seconds\n    version: string;\n    environment: string;\n    activeConnections: number;\n    requestsPerSecond: number;\n    errorRate: number; // percentage\n  };\n}\n\nexport interface PerformanceMetrics {\n  timestamp: number;\n  endpoint: string;\n  method: string;\n  responseTime: number; // milliseconds\n  statusCode: number;\n  requestSize: number; // bytes\n  responseSize: number; // bytes\n  userId?: string;\n  userAgent?: string;\n  ip?: string;\n}\n\nexport interface AIModelMetrics {\n  timestamp: number;\n  modelId: string;\n  provider: string;\n  requestCount: number;\n  averageLatency: number; // milliseconds\n  p95Latency: number; // milliseconds\n  p99Latency: number; // milliseconds\n  errorRate: number; // percentage\n  tokensProcessed: number;\n  cost: number; // USD\n  accuracy?: number; // percentage\n  throughput: number; // requests/second\n}\n\nexport interface VectorSearchMetrics {\n  timestamp: number;\n  indexName: string;\n  queryType: 'similarity' | 'hybrid' | 'filter';\n  vectorDimensions: number;\n  resultCount: number;\n  searchTime: number; // milliseconds\n  indexSize: number; // number of vectors\n  similarity: number; // average similarity score\n  cacheHit: boolean;\n}\n\nexport interface WorkspaceMetrics {\n  timestamp: number;\n  workspaceId: string;\n  activeUsers: number;\n  knowledgeNodes: number;\n  knowledgeEdges: number;\n  collaborationEvents: number;\n  syncLatency: number; // milliseconds\n  storageUsed: number; // bytes\n}\n\nexport interface HealthStatus {\n  service: string;\n  status: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';\n  lastCheck: number;\n  responseTime: number; // milliseconds\n  details: {\n    checks: HealthCheck[];\n    dependencies: DependencyStatus[];\n  };\n  uptime: number; // seconds\n  version: string;\n}\n\nexport interface HealthCheck {\n  name: string;\n  status: 'pass' | 'fail' | 'warn';\n  message?: string;\n  duration: number; // milliseconds\n  timestamp: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface DependencyStatus {\n  name: string;\n  type: 'database' | 'cache' | 'api' | 'queue' | 'storage';\n  status: 'available' | 'unavailable' | 'degraded';\n  responseTime: number; // milliseconds\n  lastCheck: number;\n  endpoint?: string;\n  version?: string;\n}\n\nexport interface Alert {\n  id: string;\n  type: 'metric' | 'health' | 'error' | 'security' | 'business';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  title: string;\n  description: string;\n  source: string;\n  timestamp: number;\n  resolved: boolean;\n  resolvedAt?: number;\n  resolvedBy?: string;\n  metadata: Record<string, any>;\n  actions?: AlertAction[];\n}\n\nexport interface AlertAction {\n  type: 'acknowledge' | 'resolve' | 'escalate' | 'suppress';\n  label: string;\n  description?: string;\n  automated?: boolean;\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  description: string;\n  enabled: boolean;\n  conditions: AlertCondition[];\n  actions: AlertRuleAction[];\n  cooldown: number; // seconds\n  severity: Alert['severity'];\n  tags: string[];\n}\n\nexport interface AlertCondition {\n  metric: string;\n  operator: 'gt' | 'lt' | 'eq' | 'ne' | 'gte' | 'lte';\n  threshold: number;\n  duration: number; // seconds\n  aggregation?: 'avg' | 'sum' | 'min' | 'max' | 'count';\n}\n\nexport interface AlertRuleAction {\n  type: 'email' | 'webhook' | 'slack' | 'pagerduty' | 'auto-resolve';\n  config: Record<string, any>;\n  enabled: boolean;\n}\n\nexport interface TraceSpan {\n  traceId: string;\n  spanId: string;\n  parentSpanId?: string;\n  operationName: string;\n  startTime: number;\n  endTime: number;\n  duration: number; // milliseconds\n  tags: Record<string, any>;\n  logs: TraceLog[];\n  status: 'ok' | 'error' | 'timeout';\n  service: string;\n  component: string;\n}\n\nexport interface TraceLog {\n  timestamp: number;\n  level: 'debug' | 'info' | 'warn' | 'error';\n  message: string;\n  fields?: Record<string, any>;\n}\n\nexport interface Trace {\n  traceId: string;\n  spans: TraceSpan[];\n  startTime: number;\n  endTime: number;\n  duration: number; // milliseconds\n  services: string[];\n  operationName: string;\n  status: 'ok' | 'error' | 'timeout';\n  tags: Record<string, any>;\n}\n\nexport interface MonitoringConfig {\n  metrics: {\n    enabled: boolean;\n    interval: number; // seconds\n    retention: number; // seconds\n    aggregation: {\n      enabled: boolean;\n      intervals: number[]; // seconds\n    };\n  };\n  health: {\n    enabled: boolean;\n    interval: number; // seconds\n    timeout: number; // seconds\n    endpoints: string[];\n  };\n  alerts: {\n    enabled: boolean;\n    rules: AlertRule[];\n    channels: AlertChannel[];\n  };\n  tracing: {\n    enabled: boolean;\n    sampleRate: number; // 0-1\n    maxSpans: number;\n    retention: number; // seconds\n  };\n  dashboard: {\n    enabled: boolean;\n    refreshInterval: number; // seconds\n    charts: DashboardChart[];\n  };\n}\n\nexport interface AlertChannel {\n  id: string;\n  type: 'email' | 'webhook' | 'slack' | 'pagerduty';\n  name: string;\n  config: Record<string, any>;\n  enabled: boolean;\n}\n\nexport interface DashboardChart {\n  id: string;\n  title: string;\n  type: 'line' | 'bar' | 'pie' | 'gauge' | 'table';\n  metrics: string[];\n  timeRange: string;\n  refreshInterval: number; // seconds\n  config: Record<string, any>;\n}\n\nexport interface MetricQuery {\n  metric: string;\n  timeRange: {\n    start: number;\n    end: number;\n  };\n  aggregation?: 'avg' | 'sum' | 'min' | 'max' | 'count';\n  groupBy?: string[];\n  filters?: Record<string, any>;\n  interval?: number; // seconds\n}\n\nexport interface MetricResult {\n  metric: string;\n  timestamps: number[];\n  values: number[];\n  labels?: Record<string, string>;\n}\n\nexport interface SystemEvent {\n  id: string;\n  type: 'deployment' | 'configuration' | 'incident' | 'maintenance';\n  title: string;\n  description: string;\n  timestamp: number;\n  duration?: number; // seconds\n  impact: 'none' | 'low' | 'medium' | 'high';\n  services: string[];\n  metadata: Record<string, any>;\n}\n\nexport interface PerformanceProfile {\n  timestamp: number;\n  service: string;\n  endpoint: string;\n  samples: {\n    cpu: number[];\n    memory: number[];\n    duration: number[];\n  };\n  hotspots: {\n    function: string;\n    file: string;\n    line: number;\n    percentage: number;\n  }[];\n  recommendations: string[];\n}\n\nexport interface CapacityPlan {\n  service: string;\n  currentCapacity: {\n    cpu: number;\n    memory: number;\n    storage: number;\n    network: number;\n  };\n  projectedGrowth: {\n    timeframe: string; // e.g., '30d', '90d', '1y'\n    cpu: number;\n    memory: number;\n    storage: number;\n    network: number;\n  };\n  recommendations: {\n    action: 'scale_up' | 'scale_down' | 'optimize' | 'monitor';\n    priority: 'low' | 'medium' | 'high';\n    description: string;\n    estimatedCost: number;\n    timeline: string;\n  }[];\n  lastUpdated: number;\n}\n"