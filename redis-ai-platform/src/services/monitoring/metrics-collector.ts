import { Redis } from 'ioredis';\nimport { logger } from '../../utils/logger';\nimport {\n  SystemMetrics,\n  PerformanceMetrics,\n  AIModelMetrics,\n  VectorSearchMetrics,\n  WorkspaceMetrics,\n  MetricQuery,\n  MetricResult,\n  MonitoringConfig,\n} from './types';\n\nexport class MetricsCollector {\n  private redis: Redis;\n  private config: MonitoringConfig;\n  private collectionInterval: NodeJS.Timeout | null = null;\n  private metricsBuffer: Map<string, any[]> = new Map();\n  private readonly BUFFER_SIZE = 1000;\n  private readonly FLUSH_INTERVAL = 10000; // 10 seconds\n\n  constructor(redis: Redis, config: MonitoringConfig) {\n    this.redis = redis;\n    this.config = config;\n    \n    if (config.metrics.enabled) {\n      this.startCollection();\n    }\n  }\n\n  private startCollection(): void {\n    // Start periodic system metrics collection\n    this.collectionInterval = setInterval(async () => {\n      try {\n        await this.collectSystemMetrics();\n      } catch (error) {\n        logger.error('Failed to collect system metrics:', error);\n      }\n    }, this.config.metrics.interval * 1000);\n\n    // Start buffer flushing\n    setInterval(() => {\n      this.flushBuffers();\n    }, this.FLUSH_INTERVAL);\n\n    logger.info('Metrics collection started');\n  }\n\n  public async collectSystemMetrics(): Promise<void> {\n    const timestamp = Date.now();\n    \n    try {\n      const metrics: SystemMetrics = {\n        timestamp,\n        cpu: await this.getCPUMetrics(),\n        memory: await this.getMemoryMetrics(),\n        redis: await this.getRedisMetrics(),\n        network: await this.getNetworkMetrics(),\n        application: await this.getApplicationMetrics(),\n      };\n\n      await this.storeMetric('system', metrics);\n      this.bufferMetric('system', metrics);\n      \n    } catch (error) {\n      logger.error('Failed to collect system metrics:', error);\n    }\n  }\n\n  public async recordPerformanceMetric(metric: PerformanceMetrics): Promise<void> {\n    try {\n      await this.storeMetric('performance', metric);\n      this.bufferMetric('performance', metric);\n      \n      // Update aggregated metrics\n      await this.updateAggregatedMetrics('performance', metric);\n      \n    } catch (error) {\n      logger.error('Failed to record performance metric:', error);\n    }\n  }\n\n  public async recordAIModelMetric(metric: AIModelMetrics): Promise<void> {\n    try {\n      await this.storeMetric('ai_model', metric);\n      this.bufferMetric('ai_model', metric);\n      \n      // Update model-specific metrics\n      await this.updateModelMetrics(metric);\n      \n    } catch (error) {\n      logger.error('Failed to record AI model metric:', error);\n    }\n  }\n\n  public async recordVectorSearchMetric(metric: VectorSearchMetrics): Promise<void> {\n    try {\n      await this.storeMetric('vector_search', metric);\n      this.bufferMetric('vector_search', metric);\n      \n      // Update search performance metrics\n      await this.updateSearchMetrics(metric);\n      \n    } catch (error) {\n      logger.error('Failed to record vector search metric:', error);\n    }\n  }\n\n  public async recordWorkspaceMetric(metric: WorkspaceMetrics): Promise<void> {\n    try {\n      await this.storeMetric('workspace', metric);\n      this.bufferMetric('workspace', metric);\n      \n    } catch (error) {\n      logger.error('Failed to record workspace metric:', error);\n    }\n  }\n\n  public async queryMetrics(query: MetricQuery): Promise<MetricResult[]> {\n    try {\n      const key = `metrics:${query.metric}`;\n      const results: MetricResult[] = [];\n      \n      // Query time series data from Redis\n      const timeSeriesData = await this.redis.ts.range(\n        key,\n        query.timeRange.start,\n        query.timeRange.end,\n        {\n          aggregation: query.aggregation ? {\n            type: query.aggregation.toUpperCase() as any,\n            timeBucket: query.interval || 60000, // 1 minute default\n          } : undefined,\n        }\n      );\n      \n      if (timeSeriesData && timeSeriesData.length > 0) {\n        const timestamps = timeSeriesData.map(([timestamp]) => timestamp);\n        const values = timeSeriesData.map(([, value]) => value);\n        \n        results.push({\n          metric: query.metric,\n          timestamps,\n          values,\n        });\n      }\n      \n      return results;\n      \n    } catch (error) {\n      logger.error('Failed to query metrics:', error);\n      return [];\n    }\n  }\n\n  public async getMetricSummary(metric: string, timeRange: { start: number; end: number }): Promise<any> {\n    try {\n      const key = `metrics:${metric}`;\n      \n      // Get aggregated statistics\n      const [avg, min, max, count] = await Promise.all([\n        this.redis.ts.range(key, timeRange.start, timeRange.end, {\n          aggregation: { type: 'AVG', timeBucket: timeRange.end - timeRange.start },\n        }),\n        this.redis.ts.range(key, timeRange.start, timeRange.end, {\n          aggregation: { type: 'MIN', timeBucket: timeRange.end - timeRange.start },\n        }),\n        this.redis.ts.range(key, timeRange.start, timeRange.end, {\n          aggregation: { type: 'MAX', timeBucket: timeRange.end - timeRange.start },\n        }),\n        this.redis.ts.range(key, timeRange.start, timeRange.end, {\n          aggregation: { type: 'COUNT', timeBucket: timeRange.end - timeRange.start },\n        }),\n      ]);\n      \n      return {\n        metric,\n        timeRange,\n        summary: {\n          average: avg[0]?.[1] || 0,\n          minimum: min[0]?.[1] || 0,\n          maximum: max[0]?.[1] || 0,\n          count: count[0]?.[1] || 0,\n        },\n      };\n      \n    } catch (error) {\n      logger.error('Failed to get metric summary:', error);\n      return null;\n    }\n  }\n\n  private async getCPUMetrics(): Promise<SystemMetrics['cpu']> {\n    const cpuUsage = process.cpuUsage();\n    const loadAverage = process.loadavg ? process.loadavg() : [0, 0, 0];\n    \n    return {\n      usage: (cpuUsage.user + cpuUsage.system) / 1000000, // Convert to percentage\n      loadAverage,\n      cores: require('os').cpus().length,\n    };\n  }\n\n  private async getMemoryMetrics(): Promise<SystemMetrics['memory']> {\n    const memUsage = process.memoryUsage();\n    const totalMem = require('os').totalmem();\n    const freeMem = require('os').freemem();\n    const usedMem = totalMem - freeMem;\n    \n    return {\n      used: usedMem,\n      total: totalMem,\n      free: freeMem,\n      percentage: (usedMem / totalMem) * 100,\n    };\n  }\n\n  private async getRedisMetrics(): Promise<SystemMetrics['redis']> {\n    try {\n      const info = await this.redis.info('memory');\n      const stats = await this.redis.info('stats');\n      const keyspace = await this.redis.info('keyspace');\n      \n      // Parse Redis info\n      const memoryUsed = this.parseRedisInfo(info, 'used_memory') || 0;\n      const connections = this.parseRedisInfo(stats, 'connected_clients') || 0;\n      const operations = this.parseRedisInfo(stats, 'instantaneous_ops_per_sec') || 0;\n      const keyspaceHits = this.parseRedisInfo(stats, 'keyspace_hits') || 0;\n      const keyspaceMisses = this.parseRedisInfo(stats, 'keyspace_misses') || 0;\n      const totalKeys = this.parseRedisKeyspace(keyspace);\n      \n      const hitRate = keyspaceHits + keyspaceMisses > 0 \n        ? (keyspaceHits / (keyspaceHits + keyspaceMisses)) * 100 \n        : 0;\n      \n      return {\n        connected: this.redis.status === 'ready',\n        memory: memoryUsed,\n        operations,\n        connections,\n        hitRate,\n        keyCount: totalKeys,\n      };\n      \n    } catch (error) {\n      logger.error('Failed to get Redis metrics:', error);\n      return {\n        connected: false,\n        memory: 0,\n        operations: 0,\n        connections: 0,\n        hitRate: 0,\n        keyCount: 0,\n      };\n    }\n  }\n\n  private async getNetworkMetrics(): Promise<SystemMetrics['network']> {\n    // Mock network metrics - in production, use system monitoring tools\n    return {\n      bytesIn: Math.random() * 1000000,\n      bytesOut: Math.random() * 1000000,\n      packetsIn: Math.random() * 10000,\n      packetsOut: Math.random() * 10000,\n    };\n  }\n\n  private async getApplicationMetrics(): Promise<SystemMetrics['application']> {\n    return {\n      uptime: process.uptime(),\n      version: process.env.npm_package_version || '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      activeConnections: await this.getActiveConnections(),\n      requestsPerSecond: await this.getRequestsPerSecond(),\n      errorRate: await this.getErrorRate(),\n    };\n  }\n\n  private async storeMetric(type: string, metric: any): Promise<void> {\n    const key = `metrics:${type}:${metric.timestamp}`;\n    const timeSeriesKey = `metrics:${type}`;\n    \n    try {\n      // Store detailed metric data\n      await this.redis.setex(key, this.config.metrics.retention, JSON.stringify(metric));\n      \n      // Store in time series for efficient querying\n      await this.redis.ts.add(timeSeriesKey, metric.timestamp, this.getMetricValue(metric));\n      \n      // Set retention policy\n      await this.redis.ts.alter(timeSeriesKey, {\n        retentionTime: this.config.metrics.retention * 1000,\n      });\n      \n    } catch (error) {\n      // If time series doesn't exist, create it\n      if (error.message?.includes('TSDB-KeyNotExists')) {\n        await this.redis.ts.create(timeSeriesKey, {\n          retentionTime: this.config.metrics.retention * 1000,\n        });\n        await this.redis.ts.add(timeSeriesKey, metric.timestamp, this.getMetricValue(metric));\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  private bufferMetric(type: string, metric: any): void {\n    if (!this.metricsBuffer.has(type)) {\n      this.metricsBuffer.set(type, []);\n    }\n    \n    const buffer = this.metricsBuffer.get(type)!;\n    buffer.push(metric);\n    \n    // Keep buffer size manageable\n    if (buffer.length > this.BUFFER_SIZE) {\n      buffer.shift();\n    }\n  }\n\n  private async flushBuffers(): Promise<void> {\n    for (const [type, metrics] of this.metricsBuffer.entries()) {\n      if (metrics.length > 0) {\n        try {\n          // Process buffered metrics for real-time analytics\n          await this.processBufferedMetrics(type, metrics);\n          \n          // Clear buffer\n          this.metricsBuffer.set(type, []);\n          \n        } catch (error) {\n          logger.error(`Failed to flush ${type} metrics buffer:`, error);\n        }\n      }\n    }\n  }\n\n  private async processBufferedMetrics(type: string, metrics: any[]): Promise<void> {\n    // Calculate real-time aggregations\n    const aggregations = this.calculateAggregations(metrics);\n    \n    // Store aggregations\n    const key = `metrics:${type}:aggregated:${Date.now()}`;\n    await this.redis.setex(key, 3600, JSON.stringify(aggregations)); // 1 hour retention\n  }\n\n  private calculateAggregations(metrics: any[]): any {\n    if (metrics.length === 0) return {};\n    \n    const values = metrics.map(m => this.getMetricValue(m)).filter(v => typeof v === 'number');\n    \n    if (values.length === 0) return {};\n    \n    return {\n      count: values.length,\n      sum: values.reduce((a, b) => a + b, 0),\n      avg: values.reduce((a, b) => a + b, 0) / values.length,\n      min: Math.min(...values),\n      max: Math.max(...values),\n      p50: this.percentile(values, 0.5),\n      p95: this.percentile(values, 0.95),\n      p99: this.percentile(values, 0.99),\n    };\n  }\n\n  private percentile(values: number[], p: number): number {\n    const sorted = values.sort((a, b) => a - b);\n    const index = Math.ceil(sorted.length * p) - 1;\n    return sorted[Math.max(0, index)];\n  }\n\n  private getMetricValue(metric: any): number {\n    // Extract primary numeric value from metric for time series storage\n    if (typeof metric === 'number') return metric;\n    \n    if (metric.responseTime) return metric.responseTime;\n    if (metric.averageLatency) return metric.averageLatency;\n    if (metric.searchTime) return metric.searchTime;\n    if (metric.cpu?.usage) return metric.cpu.usage;\n    if (metric.memory?.percentage) return metric.memory.percentage;\n    \n    return 0;\n  }\n\n  private parseRedisInfo(info: string, key: string): number | null {\n    const lines = info.split('\\r\\n');\n    for (const line of lines) {\n      if (line.startsWith(`${key}:`)) {\n        const value = line.split(':')[1];\n        return parseInt(value, 10) || 0;\n      }\n    }\n    return null;\n  }\n\n  private parseRedisKeyspace(keyspace: string): number {\n    const lines = keyspace.split('\\r\\n');\n    let totalKeys = 0;\n    \n    for (const line of lines) {\n      if (line.startsWith('db')) {\n        const match = line.match(/keys=(\\d+)/);\n        if (match) {\n          totalKeys += parseInt(match[1], 10);\n        }\n      }\n    }\n    \n    return totalKeys;\n  }\n\n  private async updateAggregatedMetrics(type: string, metric: PerformanceMetrics): Promise<void> {\n    const key = `metrics:${type}:${metric.endpoint}:aggregated`;\n    const current = await this.redis.hgetall(key);\n    \n    const count = parseInt(current.count || '0') + 1;\n    const totalTime = parseFloat(current.totalTime || '0') + metric.responseTime;\n    const avgTime = totalTime / count;\n    \n    await this.redis.hset(key, {\n      count: count.toString(),\n      totalTime: totalTime.toString(),\n      avgTime: avgTime.toString(),\n      lastUpdate: Date.now().toString(),\n    });\n    \n    await this.redis.expire(key, 3600); // 1 hour expiration\n  }\n\n  private async updateModelMetrics(metric: AIModelMetrics): Promise<void> {\n    const key = `metrics:ai_model:${metric.modelId}:current`;\n    \n    await this.redis.hset(key, {\n      averageLatency: metric.averageLatency.toString(),\n      p95Latency: metric.p95Latency.toString(),\n      errorRate: metric.errorRate.toString(),\n      throughput: metric.throughput.toString(),\n      lastUpdate: metric.timestamp.toString(),\n    });\n    \n    await this.redis.expire(key, 300); // 5 minutes expiration\n  }\n\n  private async updateSearchMetrics(metric: VectorSearchMetrics): Promise<void> {\n    const key = `metrics:vector_search:${metric.indexName}:current`;\n    \n    await this.redis.hset(key, {\n      averageSearchTime: metric.searchTime.toString(),\n      indexSize: metric.indexSize.toString(),\n      averageSimilarity: metric.similarity.toString(),\n      lastUpdate: metric.timestamp.toString(),\n    });\n    \n    await this.redis.expire(key, 300); // 5 minutes expiration\n  }\n\n  private async getActiveConnections(): Promise<number> {\n    // This would be implemented based on your connection tracking\n    return Math.floor(Math.random() * 100);\n  }\n\n  private async getRequestsPerSecond(): Promise<number> {\n    // This would be calculated from recent request metrics\n    return Math.floor(Math.random() * 1000);\n  }\n\n  private async getErrorRate(): Promise<number> {\n    // This would be calculated from recent error metrics\n    return Math.random() * 5; // 0-5% error rate\n  }\n\n  public async stop(): Promise<void> {\n    if (this.collectionInterval) {\n      clearInterval(this.collectionInterval);\n      this.collectionInterval = null;\n    }\n    \n    // Flush remaining buffers\n    await this.flushBuffers();\n    \n    logger.info('Metrics collection stopped');\n  }\n}\n"