import { Redis } from 'ioredis';\nimport { logger } from '../../utils/logger';\nimport {\n  Trace,\n  TraceSpan,\n  TraceLog,\n  MonitoringConfig,\n} from './types';\n\nexport class TracingService {\n  private redis: Redis;\n  private config: MonitoringConfig;\n  private activeTraces: Map<string, Trace> = new Map();\n  private activeSpans: Map<string, TraceSpan> = new Map();\n  private cleanupInterval: NodeJS.Timeout | null = null;\n\n  constructor(redis: Redis, config: MonitoringConfig) {\n    this.redis = redis;\n    this.config = config;\n    \n    if (config.tracing.enabled) {\n      this.startCleanup();\n    }\n  }\n\n  private startCleanup(): void {\n    // Clean up old traces periodically\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupOldTraces();\n    }, 300000); // 5 minutes\n\n    logger.info('Tracing service started');\n  }\n\n  public startTrace(operationName: string, tags: Record<string, any> = {}): string {\n    if (!this.config.tracing.enabled) {\n      return '';\n    }\n\n    // Sample based on configured rate\n    if (Math.random() > this.config.tracing.sampleRate) {\n      return '';\n    }\n\n    const traceId = this.generateTraceId();\n    const trace: Trace = {\n      traceId,\n      spans: [],\n      startTime: Date.now(),\n      endTime: 0,\n      duration: 0,\n      services: [],\n      operationName,\n      status: 'ok',\n      tags,\n    };\n\n    this.activeTraces.set(traceId, trace);\n    \n    logger.debug(`Trace started: ${traceId}`, { operationName, tags });\n    \n    return traceId;\n  }\n\n  public startSpan(\n    traceId: string,\n    operationName: string,\n    parentSpanId?: string,\n    tags: Record<string, any> = {}\n  ): string {\n    if (!traceId || !this.config.tracing.enabled) {\n      return '';\n    }\n\n    const trace = this.activeTraces.get(traceId);\n    if (!trace) {\n      return '';\n    }\n\n    const spanId = this.generateSpanId();\n    const span: TraceSpan = {\n      traceId,\n      spanId,\n      parentSpanId,\n      operationName,\n      startTime: Date.now(),\n      endTime: 0,\n      duration: 0,\n      tags: {\n        'span.kind': 'internal',\n        'component': 'redis-ai-platform',\n        ...tags,\n      },\n      logs: [],\n      status: 'ok',\n      service: tags.service || 'unknown',\n      component: tags.component || 'unknown',\n    };\n\n    this.activeSpans.set(spanId, span);\n    trace.spans.push(span);\n    \n    // Add service to trace if not already present\n    if (!trace.services.includes(span.service)) {\n      trace.services.push(span.service);\n    }\n\n    logger.debug(`Span started: ${spanId}`, { traceId, operationName, parentSpanId });\n    \n    return spanId;\n  }\n\n  public finishSpan(spanId: string, status: TraceSpan['status'] = 'ok', tags: Record<string, any> = {}): void {\n    if (!spanId || !this.config.tracing.enabled) {\n      return;\n    }\n\n    const span = this.activeSpans.get(spanId);\n    if (!span) {\n      return;\n    }\n\n    span.endTime = Date.now();\n    span.duration = span.endTime - span.startTime;\n    span.status = status;\n    span.tags = { ...span.tags, ...tags };\n\n    this.activeSpans.delete(spanId);\n    \n    logger.debug(`Span finished: ${spanId}`, { \n      traceId: span.traceId, \n      duration: span.duration, \n      status \n    });\n\n    // Check if this was the root span\n    const trace = this.activeTraces.get(span.traceId);\n    if (trace && !span.parentSpanId) {\n      this.finishTrace(span.traceId, status);\n    }\n  }\n\n  public finishTrace(traceId: string, status: Trace['status'] = 'ok'): void {\n    if (!traceId || !this.config.tracing.enabled) {\n      return;\n    }\n\n    const trace = this.activeTraces.get(traceId);\n    if (!trace) {\n      return;\n    }\n\n    trace.endTime = Date.now();\n    trace.duration = trace.endTime - trace.startTime;\n    trace.status = status;\n\n    // Finish any remaining active spans\n    const traceSpans = trace.spans.filter(span => span.endTime === 0);\n    traceSpans.forEach(span => {\n      span.endTime = trace.endTime;\n      span.duration = span.endTime - span.startTime;\n      this.activeSpans.delete(span.spanId);\n    });\n\n    this.activeTraces.delete(traceId);\n    \n    // Store completed trace\n    this.storeTrace(trace);\n    \n    logger.debug(`Trace finished: ${traceId}`, { \n      duration: trace.duration, \n      status, \n      spanCount: trace.spans.length \n    });\n  }\n\n  public addSpanLog(\n    spanId: string,\n    level: TraceLog['level'],\n    message: string,\n    fields: Record<string, any> = {}\n  ): void {\n    if (!spanId || !this.config.tracing.enabled) {\n      return;\n    }\n\n    const span = this.activeSpans.get(spanId);\n    if (!span) {\n      return;\n    }\n\n    const log: TraceLog = {\n      timestamp: Date.now(),\n      level,\n      message,\n      fields,\n    };\n\n    span.logs.push(log);\n    \n    // Limit log count per span\n    if (span.logs.length > 100) {\n      span.logs.shift();\n    }\n  }\n\n  public addSpanTag(spanId: string, key: string, value: any): void {\n    if (!spanId || !this.config.tracing.enabled) {\n      return;\n    }\n\n    const span = this.activeSpans.get(spanId);\n    if (span) {\n      span.tags[key] = value;\n    }\n  }\n\n  public addTraceTag(traceId: string, key: string, value: any): void {\n    if (!traceId || !this.config.tracing.enabled) {\n      return;\n    }\n\n    const trace = this.activeTraces.get(traceId);\n    if (trace) {\n      trace.tags[key] = value;\n    }\n  }\n\n  public async getTrace(traceId: string): Promise<Trace | null> {\n    try {\n      // Check active traces first\n      const activeTrace = this.activeTraces.get(traceId);\n      if (activeTrace) {\n        return activeTrace;\n      }\n\n      // Check stored traces\n      const traceData = await this.redis.get(`trace:${traceId}`);\n      if (traceData) {\n        return JSON.parse(traceData);\n      }\n\n      return null;\n      \n    } catch (error) {\n      logger.error(`Failed to get trace ${traceId}:`, error);\n      return null;\n    }\n  }\n\n  public async getTraces(\n    filters: {\n      service?: string;\n      operation?: string;\n      status?: string;\n      minDuration?: number;\n      maxDuration?: number;\n      startTime?: number;\n      endTime?: number;\n      limit?: number;\n    } = {}\n  ): Promise<Trace[]> {\n    try {\n      const limit = filters.limit || 100;\n      const traceIds = await this.redis.lrange('traces:recent', 0, limit - 1);\n      const traces: Trace[] = [];\n\n      for (const traceId of traceIds) {\n        const traceData = await this.redis.get(`trace:${traceId}`);\n        if (traceData) {\n          const trace = JSON.parse(traceData);\n          \n          // Apply filters\n          if (this.matchesFilters(trace, filters)) {\n            traces.push(trace);\n          }\n        }\n      }\n\n      return traces;\n      \n    } catch (error) {\n      logger.error('Failed to get traces:', error);\n      return [];\n    }\n  }\n\n  public async getTraceStats(timeRange: { start: number; end: number }): Promise<any> {\n    try {\n      const traces = await this.getTraces({\n        startTime: timeRange.start,\n        endTime: timeRange.end,\n        limit: 1000,\n      });\n\n      const stats = {\n        totalTraces: traces.length,\n        averageDuration: 0,\n        p50Duration: 0,\n        p95Duration: 0,\n        p99Duration: 0,\n        errorRate: 0,\n        serviceBreakdown: {} as Record<string, number>,\n        operationBreakdown: {} as Record<string, number>,\n        statusBreakdown: {\n          ok: 0,\n          error: 0,\n          timeout: 0,\n        },\n      };\n\n      if (traces.length === 0) {\n        return stats;\n      }\n\n      const durations = traces.map(t => t.duration).sort((a, b) => a - b);\n      const errorCount = traces.filter(t => t.status === 'error').length;\n\n      stats.averageDuration = durations.reduce((a, b) => a + b, 0) / durations.length;\n      stats.p50Duration = durations[Math.floor(durations.length * 0.5)];\n      stats.p95Duration = durations[Math.floor(durations.length * 0.95)];\n      stats.p99Duration = durations[Math.floor(durations.length * 0.99)];\n      stats.errorRate = (errorCount / traces.length) * 100;\n\n      // Calculate breakdowns\n      traces.forEach(trace => {\n        // Service breakdown\n        trace.services.forEach(service => {\n          stats.serviceBreakdown[service] = (stats.serviceBreakdown[service] || 0) + 1;\n        });\n\n        // Operation breakdown\n        stats.operationBreakdown[trace.operationName] = \n          (stats.operationBreakdown[trace.operationName] || 0) + 1;\n\n        // Status breakdown\n        stats.statusBreakdown[trace.status]++;\n      });\n\n      return stats;\n      \n    } catch (error) {\n      logger.error('Failed to get trace stats:', error);\n      return null;\n    }\n  }\n\n  public async getServiceMap(timeRange: { start: number; end: number }): Promise<any> {\n    try {\n      const traces = await this.getTraces({\n        startTime: timeRange.start,\n        endTime: timeRange.end,\n        limit: 1000,\n      });\n\n      const services = new Set<string>();\n      const connections = new Map<string, { count: number; avgDuration: number; errorRate: number }>();\n\n      traces.forEach(trace => {\n        trace.services.forEach(service => services.add(service));\n        \n        // Build service connections from spans\n        const spansByService = new Map<string, TraceSpan[]>();\n        trace.spans.forEach(span => {\n          if (!spansByService.has(span.service)) {\n            spansByService.set(span.service, []);\n          }\n          spansByService.get(span.service)!.push(span);\n        });\n\n        // Find parent-child relationships\n        trace.spans.forEach(span => {\n          if (span.parentSpanId) {\n            const parentSpan = trace.spans.find(s => s.spanId === span.parentSpanId);\n            if (parentSpan && parentSpan.service !== span.service) {\n              const connectionKey = `${parentSpan.service}->${span.service}`;\n              const existing = connections.get(connectionKey) || { count: 0, avgDuration: 0, errorRate: 0 };\n              \n              existing.count++;\n              existing.avgDuration = (existing.avgDuration + span.duration) / existing.count;\n              if (span.status === 'error') {\n                existing.errorRate = (existing.errorRate * (existing.count - 1) + 1) / existing.count;\n              }\n              \n              connections.set(connectionKey, existing);\n            }\n          }\n        });\n      });\n\n      return {\n        services: Array.from(services),\n        connections: Object.fromEntries(connections),\n        timeRange,\n        traceCount: traces.length,\n      };\n      \n    } catch (error) {\n      logger.error('Failed to get service map:', error);\n      return null;\n    }\n  }\n\n  private async storeTrace(trace: Trace): Promise<void> {\n    try {\n      // Store trace data\n      await this.redis.setex(\n        `trace:${trace.traceId}`,\n        this.config.tracing.retention,\n        JSON.stringify(trace)\n      );\n\n      // Add to recent traces list\n      await this.redis.lpush('traces:recent', trace.traceId);\n      await this.redis.ltrim('traces:recent', 0, 9999); // Keep last 10k traces\n\n      // Index by service\n      trace.services.forEach(async service => {\n        await this.redis.lpush(`traces:service:${service}`, trace.traceId);\n        await this.redis.ltrim(`traces:service:${service}`, 0, 999);\n      });\n\n      // Index by operation\n      await this.redis.lpush(`traces:operation:${trace.operationName}`, trace.traceId);\n      await this.redis.ltrim(`traces:operation:${trace.operationName}`, 0, 999);\n      \n    } catch (error) {\n      logger.error(`Failed to store trace ${trace.traceId}:`, error);\n    }\n  }\n\n  private matchesFilters(trace: Trace, filters: any): boolean {\n    if (filters.service && !trace.services.includes(filters.service)) {\n      return false;\n    }\n\n    if (filters.operation && trace.operationName !== filters.operation) {\n      return false;\n    }\n\n    if (filters.status && trace.status !== filters.status) {\n      return false;\n    }\n\n    if (filters.minDuration && trace.duration < filters.minDuration) {\n      return false;\n    }\n\n    if (filters.maxDuration && trace.duration > filters.maxDuration) {\n      return false;\n    }\n\n    if (filters.startTime && trace.startTime < filters.startTime) {\n      return false;\n    }\n\n    if (filters.endTime && trace.endTime > filters.endTime) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private cleanupOldTraces(): void {\n    const cutoff = Date.now() - (this.config.tracing.retention * 1000);\n    \n    // Clean up active traces that are too old\n    for (const [traceId, trace] of this.activeTraces.entries()) {\n      if (trace.startTime < cutoff) {\n        logger.warn(`Cleaning up stale trace: ${traceId}`);\n        this.finishTrace(traceId, 'timeout');\n      }\n    }\n\n    // Clean up active spans that are too old\n    for (const [spanId, span] of this.activeSpans.entries()) {\n      if (span.startTime < cutoff) {\n        logger.warn(`Cleaning up stale span: ${spanId}`);\n        this.finishSpan(spanId, 'timeout');\n      }\n    }\n  }\n\n  private generateTraceId(): string {\n    return `trace_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;\n  }\n\n  private generateSpanId(): string {\n    return `span_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;\n  }\n\n  // Middleware for automatic tracing\n  public createMiddleware() {\n    return (req: any, res: any, next: any) => {\n      if (!this.config.tracing.enabled) {\n        return next();\n      }\n\n      const traceId = this.startTrace(`${req.method} ${req.path}`, {\n        'http.method': req.method,\n        'http.url': req.url,\n        'http.path': req.path,\n        'user.id': req.user?.id,\n        'service': 'api',\n      });\n\n      const spanId = this.startSpan(traceId, `${req.method} ${req.path}`, undefined, {\n        'http.method': req.method,\n        'http.url': req.url,\n        'http.path': req.path,\n        'service': 'api',\n        'component': 'http-server',\n      });\n\n      // Add trace context to request\n      req.traceId = traceId;\n      req.spanId = spanId;\n\n      // Finish span when response ends\n      res.on('finish', () => {\n        this.addSpanTag(spanId, 'http.status_code', res.statusCode);\n        this.addSpanTag(spanId, 'http.response_size', res.get('content-length') || 0);\n        \n        const status = res.statusCode >= 400 ? 'error' : 'ok';\n        this.finishSpan(spanId, status);\n      });\n\n      next();\n    };\n  }\n\n  public async stop(): Promise<void> {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n\n    // Finish all active traces\n    for (const traceId of this.activeTraces.keys()) {\n      this.finishTrace(traceId, 'timeout');\n    }\n\n    logger.info('Tracing service stopped');\n  }\n}\n"