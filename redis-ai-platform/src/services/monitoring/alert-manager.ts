import { Redis } from 'ioredis';\nimport { logger } from '../../utils/logger';\nimport {\n  Alert,\n  AlertRule,\n  AlertCondition,\n  AlertRuleAction,\n  AlertChannel,\n  MonitoringConfig,\n  SystemMetrics,\n  PerformanceMetrics,\n  HealthStatus,\n} from './types';\n\nexport class AlertManager {\n  private redis: Redis;\n  private config: MonitoringConfig;\n  private evaluationInterval: NodeJS.Timeout | null = null;\n  private activeAlerts: Map<string, Alert> = new Map();\n  private alertCooldowns: Map<string, number> = new Map();\n\n  constructor(redis: Redis, config: MonitoringConfig) {\n    this.redis = redis;\n    this.config = config;\n    \n    if (config.alerts.enabled) {\n      this.startAlertEvaluation();\n    }\n  }\n\n  private startAlertEvaluation(): void {\n    this.evaluationInterval = setInterval(async () => {\n      try {\n        await this.evaluateAlertRules();\n      } catch (error) {\n        logger.error('Failed to evaluate alert rules:', error);\n      }\n    }, 30000); // Evaluate every 30 seconds\n\n    logger.info('Alert evaluation started');\n  }\n\n  public async evaluateAlertRules(): Promise<void> {\n    const rules = this.config.alerts.rules;\n    \n    for (const rule of rules) {\n      if (!rule.enabled) continue;\n      \n      try {\n        await this.evaluateRule(rule);\n      } catch (error) {\n        logger.error(`Failed to evaluate rule ${rule.id}:`, error);\n      }\n    }\n  }\n\n  private async evaluateRule(rule: AlertRule): Promise<void> {\n    const now = Date.now();\n    const cooldownKey = `alert_cooldown:${rule.id}`;\n    \n    // Check if rule is in cooldown\n    const lastTriggered = this.alertCooldowns.get(cooldownKey);\n    if (lastTriggered && (now - lastTriggered) < (rule.cooldown * 1000)) {\n      return;\n    }\n\n    // Evaluate all conditions\n    const conditionResults = await Promise.all(\n      rule.conditions.map(condition => this.evaluateCondition(condition))\n    );\n\n    // Check if all conditions are met\n    const allConditionsMet = conditionResults.every(result => result);\n    \n    if (allConditionsMet) {\n      await this.triggerAlert(rule);\n      this.alertCooldowns.set(cooldownKey, now);\n    }\n  }\n\n  private async evaluateCondition(condition: AlertCondition): Promise<boolean> {\n    try {\n      const endTime = Date.now();\n      const startTime = endTime - (condition.duration * 1000);\n      \n      // Get metric data from Redis TimeSeries\n      const metricKey = `metrics:${condition.metric}`;\n      const data = await this.redis.ts.range(metricKey, startTime, endTime);\n      \n      if (!data || data.length === 0) {\n        return false;\n      }\n\n      // Extract values and apply aggregation\n      const values = data.map(([, value]) => value);\n      let aggregatedValue: number;\n      \n      switch (condition.aggregation) {\n        case 'avg':\n          aggregatedValue = values.reduce((a, b) => a + b, 0) / values.length;\n          break;\n        case 'sum':\n          aggregatedValue = values.reduce((a, b) => a + b, 0);\n          break;\n        case 'min':\n          aggregatedValue = Math.min(...values);\n          break;\n        case 'max':\n          aggregatedValue = Math.max(...values);\n          break;\n        case 'count':\n          aggregatedValue = values.length;\n          break;\n        default:\n          aggregatedValue = values[values.length - 1] || 0; // Latest value\n      }\n\n      // Evaluate condition\n      return this.compareValues(aggregatedValue, condition.operator, condition.threshold);\n      \n    } catch (error) {\n      logger.error(`Failed to evaluate condition for metric ${condition.metric}:`, error);\n      return false;\n    }\n  }\n\n  private compareValues(value: number, operator: AlertCondition['operator'], threshold: number): boolean {\n    switch (operator) {\n      case 'gt': return value > threshold;\n      case 'gte': return value >= threshold;\n      case 'lt': return value < threshold;\n      case 'lte': return value <= threshold;\n      case 'eq': return value === threshold;\n      case 'ne': return value !== threshold;\n      default: return false;\n    }\n  }\n\n  private async triggerAlert(rule: AlertRule): Promise<void> {\n    const alert: Alert = {\n      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type: 'metric',\n      severity: rule.severity,\n      title: rule.name,\n      description: rule.description,\n      source: 'alert-manager',\n      timestamp: Date.now(),\n      resolved: false,\n      metadata: {\n        ruleId: rule.id,\n        conditions: rule.conditions,\n        tags: rule.tags,\n      },\n      actions: [\n        {\n          type: 'acknowledge',\n          label: 'Acknowledge',\n          description: 'Mark this alert as acknowledged',\n        },\n        {\n          type: 'resolve',\n          label: 'Resolve',\n          description: 'Mark this alert as resolved',\n        },\n      ],\n    };\n\n    // Store alert\n    await this.storeAlert(alert);\n    \n    // Add to active alerts\n    this.activeAlerts.set(alert.id, alert);\n    \n    // Execute alert actions\n    await this.executeAlertActions(alert, rule.actions);\n    \n    logger.warn(`Alert triggered: ${alert.title}`, {\n      alertId: alert.id,\n      severity: alert.severity,\n      ruleId: rule.id,\n    });\n  }\n\n  private async executeAlertActions(alert: Alert, actions: AlertRuleAction[]): Promise<void> {\n    for (const action of actions) {\n      if (!action.enabled) continue;\n      \n      try {\n        await this.executeAction(alert, action);\n      } catch (error) {\n        logger.error(`Failed to execute alert action ${action.type}:`, error);\n      }\n    }\n  }\n\n  private async executeAction(alert: Alert, action: AlertRuleAction): Promise<void> {\n    switch (action.type) {\n      case 'email':\n        await this.sendEmailAlert(alert, action.config);\n        break;\n      case 'webhook':\n        await this.sendWebhookAlert(alert, action.config);\n        break;\n      case 'slack':\n        await this.sendSlackAlert(alert, action.config);\n        break;\n      case 'pagerduty':\n        await this.sendPagerDutyAlert(alert, action.config);\n        break;\n      case 'auto-resolve':\n        await this.scheduleAutoResolve(alert, action.config);\n        break;\n      default:\n        logger.warn(`Unknown alert action type: ${action.type}`);\n    }\n  }\n\n  private async sendEmailAlert(alert: Alert, config: any): Promise<void> {\n    // Mock email sending - integrate with actual email service\n    logger.info(`Email alert sent: ${alert.title}`, {\n      to: config.recipients,\n      subject: `[${alert.severity.toUpperCase()}] ${alert.title}`,\n      alertId: alert.id,\n    });\n    \n    // Store notification record\n    await this.redis.lpush('alert_notifications:email', JSON.stringify({\n      alertId: alert.id,\n      type: 'email',\n      recipients: config.recipients,\n      timestamp: Date.now(),\n      status: 'sent',\n    }));\n  }\n\n  private async sendWebhookAlert(alert: Alert, config: any): Promise<void> {\n    // Mock webhook sending - integrate with actual HTTP client\n    logger.info(`Webhook alert sent: ${alert.title}`, {\n      url: config.url,\n      method: config.method || 'POST',\n      alertId: alert.id,\n    });\n    \n    // Store notification record\n    await this.redis.lpush('alert_notifications:webhook', JSON.stringify({\n      alertId: alert.id,\n      type: 'webhook',\n      url: config.url,\n      timestamp: Date.now(),\n      status: 'sent',\n    }));\n  }\n\n  private async sendSlackAlert(alert: Alert, config: any): Promise<void> {\n    // Mock Slack sending - integrate with Slack API\n    logger.info(`Slack alert sent: ${alert.title}`, {\n      channel: config.channel,\n      webhook: config.webhook,\n      alertId: alert.id,\n    });\n    \n    // Store notification record\n    await this.redis.lpush('alert_notifications:slack', JSON.stringify({\n      alertId: alert.id,\n      type: 'slack',\n      channel: config.channel,\n      timestamp: Date.now(),\n      status: 'sent',\n    }));\n  }\n\n  private async sendPagerDutyAlert(alert: Alert, config: any): Promise<void> {\n    // Mock PagerDuty sending - integrate with PagerDuty API\n    logger.info(`PagerDuty alert sent: ${alert.title}`, {\n      serviceKey: config.serviceKey,\n      alertId: alert.id,\n    });\n    \n    // Store notification record\n    await this.redis.lpush('alert_notifications:pagerduty', JSON.stringify({\n      alertId: alert.id,\n      type: 'pagerduty',\n      serviceKey: config.serviceKey,\n      timestamp: Date.now(),\n      status: 'sent',\n    }));\n  }\n\n  private async scheduleAutoResolve(alert: Alert, config: any): Promise<void> {\n    const resolveAfter = config.resolveAfter || 3600; // 1 hour default\n    \n    setTimeout(async () => {\n      try {\n        await this.resolveAlert(alert.id, 'auto-resolve');\n      } catch (error) {\n        logger.error(`Failed to auto-resolve alert ${alert.id}:`, error);\n      }\n    }, resolveAfter * 1000);\n    \n    logger.info(`Auto-resolve scheduled for alert ${alert.id} in ${resolveAfter}s`);\n  }\n\n  public async createAlert(alertData: Omit<Alert, 'id' | 'timestamp'>): Promise<Alert> {\n    const alert: Alert = {\n      ...alertData,\n      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now(),\n    };\n\n    await this.storeAlert(alert);\n    this.activeAlerts.set(alert.id, alert);\n    \n    logger.info(`Manual alert created: ${alert.title}`, { alertId: alert.id });\n    \n    return alert;\n  }\n\n  public async acknowledgeAlert(alertId: string, acknowledgedBy: string): Promise<boolean> {\n    try {\n      const alert = this.activeAlerts.get(alertId);\n      if (!alert) {\n        return false;\n      }\n\n      alert.metadata.acknowledgedBy = acknowledgedBy;\n      alert.metadata.acknowledgedAt = Date.now();\n      \n      await this.updateAlert(alert);\n      \n      logger.info(`Alert acknowledged: ${alertId}`, { acknowledgedBy });\n      return true;\n      \n    } catch (error) {\n      logger.error(`Failed to acknowledge alert ${alertId}:`, error);\n      return false;\n    }\n  }\n\n  public async resolveAlert(alertId: string, resolvedBy: string): Promise<boolean> {\n    try {\n      const alert = this.activeAlerts.get(alertId);\n      if (!alert) {\n        return false;\n      }\n\n      alert.resolved = true;\n      alert.resolvedAt = Date.now();\n      alert.resolvedBy = resolvedBy;\n      \n      await this.updateAlert(alert);\n      this.activeAlerts.delete(alertId);\n      \n      logger.info(`Alert resolved: ${alertId}`, { resolvedBy });\n      return true;\n      \n    } catch (error) {\n      logger.error(`Failed to resolve alert ${alertId}:`, error);\n      return false;\n    }\n  }\n\n  public async getActiveAlerts(): Promise<Alert[]> {\n    return Array.from(this.activeAlerts.values());\n  }\n\n  public async getAlertHistory(limit: number = 100): Promise<Alert[]> {\n    try {\n      const alertIds = await this.redis.lrange('alerts:history', 0, limit - 1);\n      const alerts: Alert[] = [];\n      \n      for (const alertId of alertIds) {\n        const alertData = await this.redis.get(`alert:${alertId}`);\n        if (alertData) {\n          alerts.push(JSON.parse(alertData));\n        }\n      }\n      \n      return alerts;\n      \n    } catch (error) {\n      logger.error('Failed to get alert history:', error);\n      return [];\n    }\n  }\n\n  public async getAlertStats(timeRange: { start: number; end: number }): Promise<any> {\n    try {\n      const alerts = await this.getAlertHistory(1000);\n      const filteredAlerts = alerts.filter(alert => \n        alert.timestamp >= timeRange.start && alert.timestamp <= timeRange.end\n      );\n      \n      const stats = {\n        total: filteredAlerts.length,\n        bySeverity: {\n          low: 0,\n          medium: 0,\n          high: 0,\n          critical: 0,\n        },\n        byType: {} as Record<string, number>,\n        resolved: filteredAlerts.filter(a => a.resolved).length,\n        averageResolutionTime: 0,\n      };\n      \n      let totalResolutionTime = 0;\n      let resolvedCount = 0;\n      \n      for (const alert of filteredAlerts) {\n        stats.bySeverity[alert.severity]++;\n        stats.byType[alert.type] = (stats.byType[alert.type] || 0) + 1;\n        \n        if (alert.resolved && alert.resolvedAt) {\n          totalResolutionTime += alert.resolvedAt - alert.timestamp;\n          resolvedCount++;\n        }\n      }\n      \n      stats.averageResolutionTime = resolvedCount > 0 \n        ? totalResolutionTime / resolvedCount \n        : 0;\n      \n      return stats;\n      \n    } catch (error) {\n      logger.error('Failed to get alert stats:', error);\n      return null;\n    }\n  }\n\n  private async storeAlert(alert: Alert): Promise<void> {\n    try {\n      // Store alert data\n      await this.redis.setex(`alert:${alert.id}`, 86400 * 30, JSON.stringify(alert)); // 30 days\n      \n      // Add to history list\n      await this.redis.lpush('alerts:history', alert.id);\n      await this.redis.ltrim('alerts:history', 0, 9999); // Keep last 10k alerts\n      \n      // Add to active alerts if not resolved\n      if (!alert.resolved) {\n        await this.redis.sadd('alerts:active', alert.id);\n      }\n      \n    } catch (error) {\n      logger.error(`Failed to store alert ${alert.id}:`, error);\n    }\n  }\n\n  private async updateAlert(alert: Alert): Promise<void> {\n    try {\n      await this.redis.setex(`alert:${alert.id}`, 86400 * 30, JSON.stringify(alert));\n      \n      if (alert.resolved) {\n        await this.redis.srem('alerts:active', alert.id);\n      }\n      \n    } catch (error) {\n      logger.error(`Failed to update alert ${alert.id}:`, error);\n    }\n  }\n\n  public async addAlertRule(rule: AlertRule): Promise<void> {\n    this.config.alerts.rules.push(rule);\n    \n    // Store rule in Redis\n    await this.redis.hset('alert_rules', rule.id, JSON.stringify(rule));\n    \n    logger.info(`Alert rule added: ${rule.name}`, { ruleId: rule.id });\n  }\n\n  public async removeAlertRule(ruleId: string): Promise<boolean> {\n    const index = this.config.alerts.rules.findIndex(rule => rule.id === ruleId);\n    if (index === -1) {\n      return false;\n    }\n    \n    this.config.alerts.rules.splice(index, 1);\n    \n    // Remove from Redis\n    await this.redis.hdel('alert_rules', ruleId);\n    \n    logger.info(`Alert rule removed: ${ruleId}`);\n    return true;\n  }\n\n  public async updateAlertRule(ruleId: string, updates: Partial<AlertRule>): Promise<boolean> {\n    const rule = this.config.alerts.rules.find(r => r.id === ruleId);\n    if (!rule) {\n      return false;\n    }\n    \n    Object.assign(rule, updates);\n    \n    // Update in Redis\n    await this.redis.hset('alert_rules', ruleId, JSON.stringify(rule));\n    \n    logger.info(`Alert rule updated: ${ruleId}`);\n    return true;\n  }\n\n  public async stop(): Promise<void> {\n    if (this.evaluationInterval) {\n      clearInterval(this.evaluationInterval);\n      this.evaluationInterval = null;\n    }\n    \n    logger.info('Alert evaluation stopped');\n  }\n}\n"