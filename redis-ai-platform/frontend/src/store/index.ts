import { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\nimport { User, UIState, Notification, WebSocketConnection } from '../types';\n\n// Auth Store\ninterface AuthState {\n  user: User | null;\n  token: string | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n  updateUser: (user: Partial<User>) => void;\n  setLoading: (loading: boolean) => void;\n}\n\nexport const useAuthStore = create<AuthState>()()\n  (devtools(\n    persist(\n      (set, get) => ({\n        user: null,\n        token: null,\n        isAuthenticated: false,\n        isLoading: false,\n\n        login: async (email: string, password: string) => {\n          set({ isLoading: true });\n          try {\n            // Mock login - replace with actual API call\n            const mockUser: User = {\n              id: '1',\n              email,\n              name: 'Demo User',\n              role: 'user',\n              preferences: {\n                theme: 'light',\n                language: 'en',\n                notifications: {\n                  email: true,\n                  push: true,\n                  workspace: true,\n                  system: true,\n                },\n                accessibility: {\n                  highContrast: false,\n                  largeText: false,\n                  reducedMotion: false,\n                  screenReader: false,\n                },\n                ui: {\n                  sidebarCollapsed: false,\n                  compactMode: false,\n                  showPreview: true,\n                  defaultView: 'grid',\n                },\n              },\n              createdAt: new Date().toISOString(),\n              lastActiveAt: new Date().toISOString(),\n            };\n            const mockToken = 'mock-jwt-token';\n            \n            localStorage.setItem('auth_token', mockToken);\n            set({ \n              user: mockUser, \n              token: mockToken, \n              isAuthenticated: true, \n              isLoading: false \n            });\n          } catch (error) {\n            set({ isLoading: false });\n            throw error;\n          }\n        },\n\n        logout: () => {\n          localStorage.removeItem('auth_token');\n          set({ user: null, token: null, isAuthenticated: false });\n        },\n\n        updateUser: (userData: Partial<User>) => {\n          const { user } = get();\n          if (user) {\n            set({ user: { ...user, ...userData } });\n          }\n        },\n\n        setLoading: (loading: boolean) => {\n          set({ isLoading: loading });\n        },\n      }),\n      {\n        name: 'auth-storage',\n        partialize: (state) => ({ \n          user: state.user, \n          token: state.token, \n          isAuthenticated: state.isAuthenticated \n        }),\n      }\n    ),\n    { name: 'auth-store' }\n  ));\n\n// UI Store\ninterface UIStore extends UIState {\n  setSidebarOpen: (open: boolean) => void;\n  setTheme: (theme: 'light' | 'dark') => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  addNotification: (notification: Omit<Notification, 'id' | 'createdAt'>) => void;\n  removeNotification: (id: string) => void;\n  clearNotifications: () => void;\n}\n\nexport const useUIStore = create<UIStore>()()\n  (devtools(\n    persist(\n      (set, get) => ({\n        sidebarOpen: true,\n        theme: 'light',\n        loading: false,\n        error: undefined,\n        notifications: [],\n\n        setSidebarOpen: (open: boolean) => {\n          set({ sidebarOpen: open });\n        },\n\n        setTheme: (theme: 'light' | 'dark') => {\n          set({ theme });\n          document.documentElement.classList.toggle('dark', theme === 'dark');\n        },\n\n        setLoading: (loading: boolean) => {\n          set({ loading });\n        },\n\n        setError: (error: string | null) => {\n          set({ error: error || undefined });\n        },\n\n        addNotification: (notification) => {\n          const id = Math.random().toString(36).substr(2, 9);\n          const newNotification: Notification = {\n            ...notification,\n            id,\n            createdAt: new Date().toISOString(),\n          };\n          \n          set((state) => ({\n            notifications: [...state.notifications, newNotification],\n          }));\n\n          // Auto-remove notification after duration\n          if (notification.duration !== 0) {\n            setTimeout(() => {\n              get().removeNotification(id);\n            }, notification.duration || 5000);\n          }\n        },\n\n        removeNotification: (id: string) => {\n          set((state) => ({\n            notifications: state.notifications.filter(n => n.id !== id),\n          }));\n        },\n\n        clearNotifications: () => {\n          set({ notifications: [] });\n        },\n      }),\n      {\n        name: 'ui-storage',\n        partialize: (state) => ({ \n          sidebarOpen: state.sidebarOpen, \n          theme: state.theme \n        }),\n      }\n    ),\n    { name: 'ui-store' }\n  ));\n\n// WebSocket Store\ninterface WebSocketStore {\n  connection: WebSocketConnection;\n  messages: any[];\n  subscriptions: Set<string>;\n  updateConnection: (connection: Partial<WebSocketConnection>) => void;\n  addMessage: (message: any) => void;\n  clearMessages: () => void;\n  addSubscription: (channel: string) => void;\n  removeSubscription: (channel: string) => void;\n}\n\nexport const useWebSocketStore = create<WebSocketStore>()()\n  (devtools(\n    (set, get) => ({\n      connection: {\n        connected: false,\n        reconnecting: false,\n        subscriptions: new Set(),\n      },\n      messages: [],\n      subscriptions: new Set(),\n\n      updateConnection: (connectionUpdate) => {\n        set((state) => ({\n          connection: { ...state.connection, ...connectionUpdate },\n        }));\n      },\n\n      addMessage: (message) => {\n        set((state) => ({\n          messages: [...state.messages.slice(-99), message], // Keep last 100 messages\n        }));\n      },\n\n      clearMessages: () => {\n        set({ messages: [] });\n      },\n\n      addSubscription: (channel) => {\n        set((state) => {\n          const newSubscriptions = new Set(state.subscriptions);\n          newSubscriptions.add(channel);\n          return { subscriptions: newSubscriptions };\n        });\n      },\n\n      removeSubscription: (channel) => {\n        set((state) => {\n          const newSubscriptions = new Set(state.subscriptions);\n          newSubscriptions.delete(channel);\n          return { subscriptions: newSubscriptions };\n        });\n      },\n    }),\n    { name: 'websocket-store' }\n  ));\n\n// Search Store\ninterface SearchStore {\n  query: string;\n  results: any[];\n  suggestions: any[];\n  filters: any;\n  isLoading: boolean;\n  history: string[];\n  setQuery: (query: string) => void;\n  setResults: (results: any[]) => void;\n  setSuggestions: (suggestions: any[]) => void;\n  setFilters: (filters: any) => void;\n  setLoading: (loading: boolean) => void;\n  addToHistory: (query: string) => void;\n  clearHistory: () => void;\n}\n\nexport const useSearchStore = create<SearchStore>()()\n  (devtools(\n    persist(\n      (set, get) => ({\n        query: '',\n        results: [],\n        suggestions: [],\n        filters: {},\n        isLoading: false,\n        history: [],\n\n        setQuery: (query: string) => {\n          set({ query });\n        },\n\n        setResults: (results: any[]) => {\n          set({ results });\n        },\n\n        setSuggestions: (suggestions: any[]) => {\n          set({ suggestions });\n        },\n\n        setFilters: (filters: any) => {\n          set({ filters });\n        },\n\n        setLoading: (loading: boolean) => {\n          set({ isLoading: loading });\n        },\n\n        addToHistory: (query: string) => {\n          if (!query.trim()) return;\n          \n          set((state) => {\n            const newHistory = [query, ...state.history.filter(h => h !== query)].slice(0, 20);\n            return { history: newHistory };\n          });\n        },\n\n        clearHistory: () => {\n          set({ history: [] });\n        },\n      }),\n      {\n        name: 'search-storage',\n        partialize: (state) => ({ \n          history: state.history,\n          filters: state.filters \n        }),\n      }\n    ),\n    { name: 'search-store' }\n  ));\n\n// Workspace Store\ninterface WorkspaceStore {\n  currentWorkspace: any | null;\n  workspaces: any[];\n  activeUsers: any[];\n  knowledgeGraph: any | null;\n  isLoading: boolean;\n  setCurrentWorkspace: (workspace: any) => void;\n  setWorkspaces: (workspaces: any[]) => void;\n  setActiveUsers: (users: any[]) => void;\n  setKnowledgeGraph: (graph: any) => void;\n  setLoading: (loading: boolean) => void;\n  addKnowledge: (knowledge: any) => void;\n  updateKnowledge: (id: string, updates: any) => void;\n  removeKnowledge: (id: string) => void;\n}\n\nexport const useWorkspaceStore = create<WorkspaceStore>()()\n  (devtools(\n    (set, get) => ({\n      currentWorkspace: null,\n      workspaces: [],\n      activeUsers: [],\n      knowledgeGraph: null,\n      isLoading: false,\n\n      setCurrentWorkspace: (workspace) => {\n        set({ currentWorkspace: workspace });\n      },\n\n      setWorkspaces: (workspaces) => {\n        set({ workspaces });\n      },\n\n      setActiveUsers: (users) => {\n        set({ activeUsers: users });\n      },\n\n      setKnowledgeGraph: (graph) => {\n        set({ knowledgeGraph: graph });\n      },\n\n      setLoading: (loading) => {\n        set({ isLoading: loading });\n      },\n\n      addKnowledge: (knowledge) => {\n        set((state) => {\n          if (!state.knowledgeGraph) return state;\n          \n          return {\n            knowledgeGraph: {\n              ...state.knowledgeGraph,\n              nodes: [...state.knowledgeGraph.nodes, knowledge],\n            },\n          };\n        });\n      },\n\n      updateKnowledge: (id, updates) => {\n        set((state) => {\n          if (!state.knowledgeGraph) return state;\n          \n          return {\n            knowledgeGraph: {\n              ...state.knowledgeGraph,\n              nodes: state.knowledgeGraph.nodes.map((node: any) =>\n                node.id === id ? { ...node, ...updates } : node\n              ),\n            },\n          };\n        });\n      },\n\n      removeKnowledge: (id) => {\n        set((state) => {\n          if (!state.knowledgeGraph) return state;\n          \n          return {\n            knowledgeGraph: {\n              ...state.knowledgeGraph,\n              nodes: state.knowledgeGraph.nodes.filter((node: any) => node.id !== id),\n              edges: state.knowledgeGraph.edges.filter(\n                (edge: any) => edge.source !== id && edge.target !== id\n              ),\n            },\n          };\n        });\n      },\n    }),\n    { name: 'workspace-store' }\n  ));\n"