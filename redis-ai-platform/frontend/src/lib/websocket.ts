import { io, Socket } from 'socket.io-client';\nimport { WebSocketMessage, WebSocketConnection } from '../types';\n\nclass WebSocketClient {\n  private socket: Socket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000;\n  private listeners: Map<string, Set<(data: any) => void>> = new Map();\n  private connectionState: WebSocketConnection = {\n    connected: false,\n    reconnecting: false,\n    subscriptions: new Set(),\n  };\n\n  constructor() {\n    this.connect();\n  }\n\n  private connect(): void {\n    const token = localStorage.getItem('auth_token');\n    \n    this.socket = io({\n      auth: {\n        token,\n      },\n      transports: ['websocket', 'polling'],\n      timeout: 20000,\n      forceNew: true,\n    });\n\n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    if (!this.socket) return;\n\n    this.socket.on('connect', () => {\n      console.log('WebSocket connected:', this.socket?.id);\n      this.connectionState.connected = true;\n      this.connectionState.reconnecting = false;\n      this.connectionState.lastConnected = new Date().toISOString();\n      this.connectionState.connectionId = this.socket?.id;\n      this.reconnectAttempts = 0;\n      \n      // Re-subscribe to channels after reconnection\n      this.resubscribe();\n      \n      // Notify connection listeners\n      this.emit('connection:status', this.connectionState);\n    });\n\n    this.socket.on('disconnect', (reason) => {\n      console.log('WebSocket disconnected:', reason);\n      this.connectionState.connected = false;\n      this.emit('connection:status', this.connectionState);\n      \n      // Attempt to reconnect if not a manual disconnect\n      if (reason !== 'io client disconnect') {\n        this.attemptReconnect();\n      }\n    });\n\n    this.socket.on('connect_error', (error) => {\n      console.error('WebSocket connection error:', error);\n      this.connectionState.connected = false;\n      this.emit('connection:error', error);\n      this.attemptReconnect();\n    });\n\n    this.socket.on('error', (error) => {\n      console.error('WebSocket error:', error);\n      this.emit('connection:error', error);\n    });\n\n    // Handle server messages\n    this.socket.onAny((event, data) => {\n      this.emit(event, data);\n    });\n  }\n\n  private attemptReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      this.connectionState.reconnecting = false;\n      this.emit('connection:failed', { attempts: this.reconnectAttempts });\n      return;\n    }\n\n    this.connectionState.reconnecting = true;\n    this.reconnectAttempts++;\n    \n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);\n    \n    setTimeout(() => {\n      if (this.socket) {\n        this.socket.connect();\n      }\n    }, delay);\n  }\n\n  private resubscribe(): void {\n    // Re-subscribe to all channels after reconnection\n    for (const channel of this.connectionState.subscriptions) {\n      this.socket?.emit('subscribe', { channel });\n    }\n  }\n\n  // Public methods\n  public on(event: string, callback: (data: any) => void): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n  }\n\n  public off(event: string, callback?: (data: any) => void): void {\n    if (!this.listeners.has(event)) return;\n    \n    if (callback) {\n      this.listeners.get(event)!.delete(callback);\n    } else {\n      this.listeners.delete(event);\n    }\n  }\n\n  public emit(event: string, data?: any): void {\n    // Emit to local listeners\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in WebSocket event listener for ${event}:`, error);\n        }\n      });\n    }\n\n    // Emit to server if connected\n    if (this.socket?.connected) {\n      this.socket.emit(event, data);\n    }\n  }\n\n  public subscribe(channel: string, params?: any): void {\n    this.connectionState.subscriptions.add(channel);\n    this.emit('subscribe', { channel, params });\n  }\n\n  public unsubscribe(channel: string): void {\n    this.connectionState.subscriptions.delete(channel);\n    this.emit('unsubscribe', { channel });\n  }\n\n  public getConnectionState(): WebSocketConnection {\n    return { ...this.connectionState };\n  }\n\n  public isConnected(): boolean {\n    return this.connectionState.connected;\n  }\n\n  public disconnect(): void {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    this.connectionState.connected = false;\n    this.connectionState.reconnecting = false;\n    this.listeners.clear();\n  }\n\n  public reconnect(): void {\n    this.disconnect();\n    this.reconnectAttempts = 0;\n    this.connect();\n  }\n\n  // Convenience methods for common operations\n  public joinWorkspace(workspaceId: string): void {\n    this.emit('workspace:join', { workspaceId });\n  }\n\n  public leaveWorkspace(workspaceId: string): void {\n    this.emit('workspace:leave', { workspaceId });\n  }\n\n  public trackBehavior(action: string, context: any): void {\n    this.emit('learning:behavior:track', { action, context });\n  }\n\n  public subscribeToAlerts(types: string[] = ['all']): void {\n    this.emit('system:subscribe_alerts', { alertTypes: types });\n  }\n\n  public subscribeToMetrics(metrics: string[] = ['all'], interval: number = 30000): void {\n    this.emit('system:subscribe_metrics', { metrics, interval });\n  }\n\n  public searchQuery(query: string, type: string = 'multi-modal', filters?: any): void {\n    this.emit('search:query', { query, type, filters });\n  }\n\n  public requestAIRouting(prompt: string, context?: any, requirements?: any): void {\n    this.emit('ai_routing:request', { prompt, context, requirements });\n  }\n\n  public trackUIInteraction(type: string, element: any, context: any): void {\n    this.emit('adaptive_ui:track_interaction', { type, element, context });\n  }\n}\n\n// Create singleton instance\nconst wsClient = new WebSocketClient();\n\nexport default wsClient;\nexport { WebSocketClient };\n"