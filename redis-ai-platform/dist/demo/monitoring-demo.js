"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
nimport;
{
    logger;
}
from;
'../utils/logger';
nimport;
{
    MonitoringService;
}
from;
'../services/monitoring';
nimport;
{
    n;
    SystemMetrics, ;
    n;
    PerformanceMetrics, ;
    n;
    AIModelMetrics, ;
    n;
    VectorSearchMetrics, ;
    n;
    WorkspaceMetrics, ;
    n;
    Alert, ;
    n;
}
from;
'../services/monitoring/types';
n;
nasync;
function runMonitoringDemo() { n; try {
    n;
    logger.info('Starting Monitoring Demo...');
    n;
    n;
}
finally { } } // Create Redis connection\n    const redis = new Redis({\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n      retryDelayOnFailover: 100,\n      maxRetriesPerRequest: 3,\n    });\n\n    // Test Redis connection\n    await redis.ping();\n    logger.info('Redis connection established');\n\n    // Initialize monitoring service\n    const monitoring = new MonitoringService(redis, {\n      metrics: {\n        enabled: true,\n        interval: 10, // 10 seconds for demo\n        retention: 3600, // 1 hour for demo\n        aggregation: {\n          enabled: true,\n          intervals: [60, 300, 900], // 1min, 5min, 15min\n        },\n      },\n      health: {\n        enabled: true,\n        interval: 15, // 15 seconds for demo\n        timeout: 5,\n        endpoints: [],\n      },\n      alerts: {\n        enabled: true,\n        rules: [],\n        channels: [],\n      },\n      tracing: {\n        enabled: true,\n        sampleRate: 1.0, // 100% sampling for demo\n        maxSpans: 100,\n        retention: 1800, // 30 minutes for demo\n      },\n      dashboard: {\n        enabled: true,\n        refreshInterval: 10, // 10 seconds for demo\n        charts: [],\n      },\n    });\n\n    await monitoring.initialize();\n    logger.info('Monitoring service initialized');\n\n    // Demo 1: System Metrics Collection\n    logger.info('\\n=== Demo 1: System Metrics Collection ===');\n    \n    // Simulate system metrics\n    const systemMetrics: SystemMetrics = {\n      timestamp: Date.now(),\n      cpu: {\n        usage: Math.random() * 80 + 10, // 10-90%\n        loadAverage: [Math.random() * 2, Math.random() * 2, Math.random() * 2],\n        cores: 8,\n      },\n      memory: {\n        used: Math.random() * 8000000000, // 0-8GB\n        total: 16000000000, // 16GB\n        free: 8000000000,\n        percentage: Math.random() * 80 + 10,\n      },\n      redis: {\n        connected: true,\n        memory: Math.random() * 1000000000, // 0-1GB\n        operations: Math.random() * 1000,\n        connections: Math.random() * 100,\n        hitRate: Math.random() * 20 + 80, // 80-100%\n        keyCount: Math.random() * 10000,\n      },\n      network: {\n        bytesIn: Math.random() * 1000000,\n        bytesOut: Math.random() * 1000000,\n        packetsIn: Math.random() * 10000,\n        packetsOut: Math.random() * 10000,\n      },\n      application: {\n        uptime: process.uptime(),\n        version: '1.0.0',\n        environment: 'demo',\n        activeConnections: Math.random() * 100,\n        requestsPerSecond: Math.random() * 1000,\n        errorRate: Math.random() * 5,\n      },\n    };\n\n    await monitoring.recordSystemMetrics(systemMetrics);\n    logger.info('System metrics recorded:', {\n      cpuUsage: systemMetrics.cpu.usage.toFixed(1) + '%',\n      memoryUsage: systemMetrics.memory.percentage.toFixed(1) + '%',\n      redisHitRate: systemMetrics.redis.hitRate.toFixed(1) + '%',\n    });\n\n    // Demo 2: Performance Metrics\n    logger.info('\\n=== Demo 2: Performance Metrics ===');\n    \n    const endpoints = ['/api/search', '/api/workspace', '/api/ai-routing', '/api/health'];\n    const methods = ['GET', 'POST', 'PUT', 'DELETE'];\n    \n    for (let i = 0; i < 10; i++) {\n      const performanceMetric: PerformanceMetrics = {\n        timestamp: Date.now() - (i * 1000), // Spread over last 10 seconds\n        endpoint: endpoints[Math.floor(Math.random() * endpoints.length)],\n        method: methods[Math.floor(Math.random() * methods.length)],\n        responseTime: Math.random() * 500 + 50, // 50-550ms\n        statusCode: Math.random() > 0.1 ? 200 : (Math.random() > 0.5 ? 404 : 500),\n        requestSize: Math.random() * 10000,\n        responseSize: Math.random() * 50000,\n        userId: `user_${Math.floor(Math.random() * 100)}`,\n        userAgent: 'Demo-Client/1.0',\n        ip: `192.168.1.${Math.floor(Math.random() * 255)}`,\n      };\n      \n      await monitoring.recordPerformanceMetric(performanceMetric);\n    }\n    \n    logger.info('Performance metrics recorded for 10 requests');\n\n    // Demo 3: AI Model Metrics\n    logger.info('\\n=== Demo 3: AI Model Metrics ===');\n    \n    const models = ['gpt-4', 'claude-3', 'local-llm'];\n    const providers = ['openai', 'anthropic', 'local'];\n    \n    for (let i = 0; i < models.length; i++) {\n      const aiModelMetric: AIModelMetrics = {\n        timestamp: Date.now(),\n        modelId: models[i],\n        provider: providers[i],\n        requestCount: Math.floor(Math.random() * 100) + 10,\n        averageLatency: Math.random() * 2000 + 500, // 500-2500ms\n        p95Latency: Math.random() * 3000 + 1000, // 1000-4000ms\n        p99Latency: Math.random() * 5000 + 2000, // 2000-7000ms\n        errorRate: Math.random() * 5, // 0-5%\n        tokensProcessed: Math.floor(Math.random() * 100000) + 10000,\n        cost: Math.random() * 50 + 5, // $5-55\n        accuracy: Math.random() * 10 + 90, // 90-100%\n        throughput: Math.random() * 100 + 20, // 20-120 req/s\n      };\n      \n      await monitoring.recordAIModelMetric(aiModelMetric);\n      \n      logger.info(`AI model metrics recorded for ${models[i]}:`, {\n        avgLatency: aiModelMetric.averageLatency.toFixed(0) + 'ms',\n        errorRate: aiModelMetric.errorRate.toFixed(1) + '%',\n        cost: '$' + aiModelMetric.cost.toFixed(2),\n      });\n    }\n\n    // Demo 4: Vector Search Metrics\n    logger.info('\\n=== Demo 4: Vector Search Metrics ===');\n    \n    const indices = ['text_embeddings', 'image_embeddings', 'code_embeddings'];\n    const queryTypes = ['similarity', 'hybrid', 'filter'] as const;\n    \n    for (let i = 0; i < 5; i++) {\n      const vectorSearchMetric: VectorSearchMetrics = {\n        timestamp: Date.now() - (i * 2000),\n        indexName: indices[Math.floor(Math.random() * indices.length)],\n        queryType: queryTypes[Math.floor(Math.random() * queryTypes.length)],\n        vectorDimensions: 1536,\n        resultCount: Math.floor(Math.random() * 50) + 1,\n        searchTime: Math.random() * 100 + 10, // 10-110ms\n        indexSize: Math.floor(Math.random() * 1000000) + 100000,\n        similarity: Math.random() * 0.3 + 0.7, // 0.7-1.0\n        cacheHit: Math.random() > 0.3,\n      };\n      \n      await monitoring.recordVectorSearchMetric(vectorSearchMetric);\n    }\n    \n    logger.info('Vector search metrics recorded for 5 queries');\n\n    // Demo 5: Workspace Metrics\n    logger.info('\\n=== Demo 5: Workspace Metrics ===');\n    \n    for (let i = 0; i < 3; i++) {\n      const workspaceMetric: WorkspaceMetrics = {\n        timestamp: Date.now(),\n        workspaceId: `workspace_${i + 1}`,\n        activeUsers: Math.floor(Math.random() * 10) + 1,\n        knowledgeNodes: Math.floor(Math.random() * 1000) + 100,\n        knowledgeEdges: Math.floor(Math.random() * 2000) + 200,\n        collaborationEvents: Math.floor(Math.random() * 50) + 5,\n        syncLatency: Math.random() * 50 + 10, // 10-60ms\n        storageUsed: Math.floor(Math.random() * 1000000000) + 100000000, // 100MB-1GB\n      };\n      \n      await monitoring.recordWorkspaceMetric(workspaceMetric);\n    }\n    \n    logger.info('Workspace metrics recorded for 3 workspaces');\n\n    // Demo 6: Health Checks\n    logger.info('\\n=== Demo 6: Health Checks ===');\n    \n    await monitoring.performHealthCheck();\n    const healthStatus = await monitoring.getHealthStatus();\n    \n    if (Array.isArray(healthStatus)) {\n      logger.info('Health check results:');\n      healthStatus.forEach(status => {\n        logger.info(`  ${status.service}: ${status.status} (${status.responseTime}ms)`);\n      });\n    }\n\n    // Demo 7: Distributed Tracing\n    logger.info('\\n=== Demo 7: Distributed Tracing ===');\n    \n    // Simulate a complex operation with multiple spans\n    const traceId = monitoring.startTrace('demo_operation', {\n      'operation.type': 'demo',\n      'user.id': 'demo_user',\n    });\n    \n    logger.info(`Started trace: ${traceId}`);\n    \n    // Simulate database operation\n    const dbSpanId = monitoring.startSpan(traceId, 'database_query', undefined, {\n      'db.type': 'redis',\n      'db.operation': 'get',\n      'service': 'database',\n    });\n    \n    await new Promise(resolve => setTimeout(resolve, 50)); // Simulate DB latency\n    monitoring.finishSpan(dbSpanId, 'ok', { 'db.rows': 5 });\n    \n    // Simulate AI model call\n    const aiSpanId = monitoring.startSpan(traceId, 'ai_model_call', undefined, {\n      'ai.model': 'gpt-4',\n      'ai.provider': 'openai',\n      'service': 'ai-routing',\n    });\n    \n    await new Promise(resolve => setTimeout(resolve, 200)); // Simulate AI latency\n    monitoring.finishSpan(aiSpanId, 'ok', { 'ai.tokens': 150 });\n    \n    // Simulate vector search\n    const searchSpanId = monitoring.startSpan(traceId, 'vector_search', undefined, {\n      'search.index': 'text_embeddings',\n      'search.query_type': 'similarity',\n      'service': 'search',\n    });\n    \n    await new Promise(resolve => setTimeout(resolve, 30)); // Simulate search latency\n    monitoring.finishSpan(searchSpanId, 'ok', { 'search.results': 10 });\n    \n    monitoring.finishTrace(traceId, 'ok');\n    logger.info('Trace completed successfully');\n\n    // Demo 8: Manual Alert Creation\n    logger.info('\\n=== Demo 8: Manual Alert Creation ===');\n    \n    const demoAlert = await monitoring.createAlert({\n      type: 'metric',\n      severity: 'medium',\n      title: 'Demo Alert',\n      description: 'This is a demonstration alert to show the alerting system',\n      source: 'monitoring-demo',\n      resolved: false,\n      metadata: {\n        demo: true,\n        createdBy: 'monitoring-demo',\n      },\n    });\n    \n    logger.info(`Created demo alert: ${demoAlert.id}`);\n    \n    // Wait a moment then resolve the alert\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    await monitoring.resolveAlert(demoAlert.id, 'monitoring-demo');\n    logger.info('Demo alert resolved');\n\n    // Demo 9: Dashboard Data\n    logger.info('\\n=== Demo 9: Dashboard Data ===');\n    \n    // Wait for dashboard to refresh\n    await new Promise(resolve => setTimeout(resolve, 3000));\n    \n    const dashboardData = await monitoring.getDashboardData();\n    logger.info('Dashboard data sections available:', Object.keys(dashboardData));\n    \n    const systemOverview = await monitoring.getSystemOverview();\n    logger.info('System overview:', {\n      uptime: Math.floor(systemOverview.uptime) + 's',\n      activeAlerts: systemOverview.alerts.active,\n      version: systemOverview.version,\n    });\n\n    // Demo 10: Metrics Summary\n    logger.info('\\n=== Demo 10: Metrics Summary ===');\n    \n    const now = Date.now();\n    const metricsSummary = await monitoring.getMetricsSummary({\n      start: now - 300000, // Last 5 minutes\n      end: now,\n    });\n    \n    logger.info('Metrics summary for last 5 minutes:');\n    Object.entries(metricsSummary.metrics).forEach(([metric, summary]) => {\n      if (summary) {\n        logger.info(`  ${metric}: avg=${summary.summary?.average?.toFixed(2) || 'N/A'}, count=${summary.summary?.count || 0}`);\n      }\n    });\n\n    // Demo 11: Trace Retrieval\n    logger.info('\\n=== Demo 11: Trace Retrieval ===');\n    \n    const retrievedTrace = await monitoring.getTrace(traceId);\n    if (retrievedTrace) {\n      logger.info('Retrieved trace:', {\n        traceId: retrievedTrace.traceId,\n        duration: retrievedTrace.duration + 'ms',\n        spanCount: retrievedTrace.spans.length,\n        services: retrievedTrace.services,\n        status: retrievedTrace.status,\n      });\n    }\n\n    logger.info('\\n=== Monitoring Demo Complete ===');\n    logger.info('Key features demonstrated:');\n    logger.info('✓ System metrics collection and storage');\n    logger.info('✓ Performance monitoring with automatic aggregation');\n    logger.info('✓ AI model performance tracking');\n    logger.info('✓ Vector search analytics');\n    logger.info('✓ Workspace collaboration metrics');\n    logger.info('✓ Comprehensive health checking');\n    logger.info('✓ Distributed tracing with span relationships');\n    logger.info('✓ Alert creation and management');\n    logger.info('✓ Real-time dashboard data');\n    logger.info('✓ Historical metrics analysis');\n    logger.info('');\n    logger.info('The monitoring system is now collecting metrics and can be integrated');\n    logger.info('with your application using the MonitoringService class.');\n    logger.info('');\n    logger.info('Next steps:');\n    logger.info('1. Add monitoring.createPerformanceMiddleware() to your Express app');\n    logger.info('2. Add monitoring.getTracingMiddleware() for distributed tracing');\n    logger.info('3. Set up alert webhooks in environment variables');\n    logger.info('4. Configure custom alert rules for your specific needs');\n    logger.info('5. Build dashboards using the dashboard service data');\n\n    // Keep the demo running for a bit to show ongoing monitoring\n    logger.info('\\nDemo will continue running for 30 seconds to show ongoing monitoring...');\n    \n    const demoInterval = setInterval(async () => {\n      // Simulate ongoing activity\n      await monitoring.recordPerformanceMetric({\n        timestamp: Date.now(),\n        endpoint: '/api/demo',\n        method: 'GET',\n        responseTime: Math.random() * 200 + 50,\n        statusCode: 200,\n        requestSize: 1024,\n        responseSize: 2048,\n        userId: 'demo_user',\n        userAgent: 'Demo-Client/1.0',\n        ip: '127.0.0.1',\n      });\n    }, 2000);\n    \n    setTimeout(async () => {\n      clearInterval(demoInterval);\n      \n      logger.info('\\nStopping monitoring demo...');\n      await monitoring.stop();\n      await redis.quit();\n      \n      logger.info('Monitoring demo stopped successfully');\n      process.exit(0);\n    }, 30000);\n\n  } catch (error) {\n    logger.error('Monitoring demo error:', error);\n    process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  runMonitoringDemo();\n}\n\nexport { runMonitoringDemo };\n"
//# sourceMappingURL=monitoring-demo.js.map