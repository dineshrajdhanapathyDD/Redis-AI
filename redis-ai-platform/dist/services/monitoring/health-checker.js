"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
nimport;
{
    logger;
}
from;
'../../utils/logger';
nimport;
{
    n;
    HealthStatus, ;
    n;
    HealthCheck, ;
    n;
    DependencyStatus, ;
    n;
    MonitoringConfig, ;
    n;
}
from;
'./types';
n;
nexport;
class HealthChecker {
    n;
    redis;
    n;
    config;
    n;
    checkInterval = null;
    n;
    healthCache = new Map();
    n;
    n;
    constructor(redis, config) { n; this.redis = redis; n; this.config = config; n; n; if (config.health.enabled) {
        n;
        this.startHealthChecks();
        n;
    } n; }
    n;
    n;
    startHealthChecks() { n; this.checkInterval = setInterval(async () => { n; try {
        n;
        await this.performHealthChecks();
        n;
    }
    catch (error) {
        n;
        logger.error('Failed to perform health checks:', error);
        n;
    } n; }, this.config.health.interval * 1000); n; n; logger.info('Health checks started'); n; }
    n;
    n;
    async performHealthChecks() { n; const services = [n, 'redis', n, 'application', n, 'vector-search', n, 'ai-models', n, 'workspace', n, 'monitoring', n]; n; n; const healthPromises = services.map(service => , n, this.checkServiceHealth(service).catch(error => { n; logger.error(`Health check failed for ${service}:`, error); n; return this.createUnhealthyStatus(service, error.message); n; }), n); n; n; const healthResults = await Promise.all(healthPromises); n; n; }
} // Update health cache\n    healthResults.forEach(health => {\n      this.healthCache.set(health.service, health);\n    });\n\n    // Store health status in Redis\n    await this.storeHealthStatus(healthResults);\n  }\n\n  public async checkServiceHealth(service: string): Promise<HealthStatus> {\n    const startTime = Date.now();\n    const checks: HealthCheck[] = [];\n    const dependencies: DependencyStatus[] = [];\n\n    try {\n      switch (service) {\n        case 'redis':\n          return await this.checkRedisHealth();\n        case 'application':\n          return await this.checkApplicationHealth();\n        case 'vector-search':\n          return await this.checkVectorSearchHealth();\n        case 'ai-models':\n          return await this.checkAIModelsHealth();\n        case 'workspace':\n          return await this.checkWorkspaceHealth();\n        case 'monitoring':\n          return await this.checkMonitoringHealth();\n        default:\n          throw new Error(`Unknown service: ${service}`);\n      }\n    } catch (error) {\n      return this.createUnhealthyStatus(service, error.message);\n    }\n  }\n\n  private async checkRedisHealth(): Promise<HealthStatus> {\n    const startTime = Date.now();\n    const checks: HealthCheck[] = [];\n    const dependencies: DependencyStatus[] = [];\n\n    try {\n      // Test basic connectivity\n      const pingStart = Date.now();\n      await this.redis.ping();\n      const pingDuration = Date.now() - pingStart;\n      \n      checks.push({\n        name: 'connectivity',\n        status: 'pass',\n        duration: pingDuration,\n        timestamp: Date.now(),\n        message: 'Redis connection successful',\n      });\n\n      // Check memory usage\n      const info = await this.redis.info('memory');\n      const usedMemory = this.parseRedisInfo(info, 'used_memory') || 0;\n      const maxMemory = this.parseRedisInfo(info, 'maxmemory') || 0;\n      const memoryUsage = maxMemory > 0 ? (usedMemory / maxMemory) * 100 : 0;\n      \n      checks.push({\n        name: 'memory_usage',\n        status: memoryUsage > 90 ? 'fail' : memoryUsage > 80 ? 'warn' : 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Memory usage: ${memoryUsage.toFixed(1)}%`,\n        metadata: { usedMemory, maxMemory, memoryUsage },\n      });\n\n      // Check connection count\n      const statsInfo = await this.redis.info('stats');\n      const connectedClients = this.parseRedisInfo(statsInfo, 'connected_clients') || 0;\n      const maxClients = this.parseRedisInfo(statsInfo, 'maxclients') || 10000;\n      const connectionUsage = (connectedClients / maxClients) * 100;\n      \n      checks.push({\n        name: 'connections',\n        status: connectionUsage > 90 ? 'fail' : connectionUsage > 80 ? 'warn' : 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Connected clients: ${connectedClients}/${maxClients}`,\n        metadata: { connectedClients, maxClients, connectionUsage },\n      });\n\n      // Test write/read operations\n      const testKey = `health_check:${Date.now()}`;\n      const testValue = 'health_check_value';\n      \n      await this.redis.setex(testKey, 60, testValue);\n      const retrievedValue = await this.redis.get(testKey);\n      await this.redis.del(testKey);\n      \n      checks.push({\n        name: 'read_write',\n        status: retrievedValue === testValue ? 'pass' : 'fail',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: 'Read/write operations successful',\n      });\n\n      const overallStatus = this.determineOverallStatus(checks);\n      \n      return {\n        service: 'redis',\n        status: overallStatus,\n        lastCheck: Date.now(),\n        responseTime: Date.now() - startTime,\n        details: { checks, dependencies },\n        uptime: this.parseRedisInfo(await this.redis.info('server'), 'uptime_in_seconds') || 0,\n        version: this.parseRedisInfo(await this.redis.info('server'), 'redis_version')?.toString() || 'unknown',\n      };\n      \n    } catch (error) {\n      checks.push({\n        name: 'connectivity',\n        status: 'fail',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Redis health check failed: ${error.message}`,\n      });\n      \n      return {\n        service: 'redis',\n        status: 'unhealthy',\n        lastCheck: Date.now(),\n        responseTime: Date.now() - startTime,\n        details: { checks, dependencies },\n        uptime: 0,\n        version: 'unknown',\n      };\n    }\n  }\n\n  private async checkApplicationHealth(): Promise<HealthStatus> {\n    const startTime = Date.now();\n    const checks: HealthCheck[] = [];\n    const dependencies: DependencyStatus[] = [];\n\n    try {\n      // Check memory usage\n      const memUsage = process.memoryUsage();\n      const memoryUsageMB = memUsage.heapUsed / 1024 / 1024;\n      const memoryLimitMB = memUsage.heapTotal / 1024 / 1024;\n      const memoryPercentage = (memoryUsageMB / memoryLimitMB) * 100;\n      \n      checks.push({\n        name: 'memory',\n        status: memoryPercentage > 90 ? 'fail' : memoryPercentage > 80 ? 'warn' : 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Memory usage: ${memoryUsageMB.toFixed(1)}MB (${memoryPercentage.toFixed(1)}%)`,\n        metadata: { memoryUsageMB, memoryLimitMB, memoryPercentage },\n      });\n\n      // Check CPU usage\n      const cpuUsage = process.cpuUsage();\n      const cpuPercentage = (cpuUsage.user + cpuUsage.system) / 1000000; // Convert to percentage\n      \n      checks.push({\n        name: 'cpu',\n        status: cpuPercentage > 90 ? 'fail' : cpuPercentage > 80 ? 'warn' : 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `CPU usage: ${cpuPercentage.toFixed(1)}%`,\n        metadata: { cpuPercentage },\n      });\n\n      // Check uptime\n      const uptime = process.uptime();\n      checks.push({\n        name: 'uptime',\n        status: 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Uptime: ${Math.floor(uptime / 3600)}h ${Math.floor((uptime % 3600) / 60)}m`,\n        metadata: { uptime },\n      });\n\n      // Check event loop lag\n      const eventLoopStart = Date.now();\n      await new Promise(resolve => setImmediate(resolve));\n      const eventLoopLag = Date.now() - eventLoopStart;\n      \n      checks.push({\n        name: 'event_loop',\n        status: eventLoopLag > 100 ? 'fail' : eventLoopLag > 50 ? 'warn' : 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Event loop lag: ${eventLoopLag}ms`,\n        metadata: { eventLoopLag },\n      });\n\n      const overallStatus = this.determineOverallStatus(checks);\n      \n      return {\n        service: 'application',\n        status: overallStatus,\n        lastCheck: Date.now(),\n        responseTime: Date.now() - startTime,\n        details: { checks, dependencies },\n        uptime,\n        version: process.env.npm_package_version || '1.0.0',\n      };\n      \n    } catch (error) {\n      return this.createUnhealthyStatus('application', error.message);\n    }\n  }\n\n  private async checkVectorSearchHealth(): Promise<HealthStatus> {\n    const startTime = Date.now();\n    const checks: HealthCheck[] = [];\n    const dependencies: DependencyStatus[] = [];\n\n    try {\n      // Check if vector indices exist\n      const indices = await this.redis.keys('vector:*');\n      \n      checks.push({\n        name: 'indices',\n        status: indices.length > 0 ? 'pass' : 'warn',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Found ${indices.length} vector indices`,\n        metadata: { indexCount: indices.length },\n      });\n\n      // Test vector search performance\n      const searchStart = Date.now();\n      // Mock vector search test\n      await new Promise(resolve => setTimeout(resolve, Math.random() * 50));\n      const searchDuration = Date.now() - searchStart;\n      \n      checks.push({\n        name: 'search_performance',\n        status: searchDuration > 1000 ? 'fail' : searchDuration > 500 ? 'warn' : 'pass',\n        duration: searchDuration,\n        timestamp: Date.now(),\n        message: `Vector search response time: ${searchDuration}ms`,\n        metadata: { searchDuration },\n      });\n\n      const overallStatus = this.determineOverallStatus(checks);\n      \n      return {\n        service: 'vector-search',\n        status: overallStatus,\n        lastCheck: Date.now(),\n        responseTime: Date.now() - startTime,\n        details: { checks, dependencies },\n        uptime: process.uptime(),\n        version: '1.0.0',\n      };\n      \n    } catch (error) {\n      return this.createUnhealthyStatus('vector-search', error.message);\n    }\n  }\n\n  private async checkAIModelsHealth(): Promise<HealthStatus> {\n    const startTime = Date.now();\n    const checks: HealthCheck[] = [];\n    const dependencies: DependencyStatus[] = [];\n\n    try {\n      // Check model availability\n      const modelKeys = await this.redis.keys('ai_model:*:status');\n      const availableModels = [];\n      \n      for (const key of modelKeys) {\n        const status = await this.redis.get(key);\n        if (status === 'available') {\n          availableModels.push(key.split(':')[1]);\n        }\n      }\n      \n      checks.push({\n        name: 'model_availability',\n        status: availableModels.length > 0 ? 'pass' : 'fail',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `${availableModels.length} AI models available`,\n        metadata: { availableModels, totalModels: modelKeys.length },\n      });\n\n      // Check model performance metrics\n      const performanceMetrics = await this.redis.hgetall('metrics:ai_model:performance');\n      const avgLatency = parseFloat(performanceMetrics.avgLatency || '0');\n      const errorRate = parseFloat(performanceMetrics.errorRate || '0');\n      \n      checks.push({\n        name: 'model_performance',\n        status: avgLatency > 5000 || errorRate > 10 ? 'fail' : avgLatency > 2000 || errorRate > 5 ? 'warn' : 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Avg latency: ${avgLatency}ms, Error rate: ${errorRate}%`,\n        metadata: { avgLatency, errorRate },\n      });\n\n      const overallStatus = this.determineOverallStatus(checks);\n      \n      return {\n        service: 'ai-models',\n        status: overallStatus,\n        lastCheck: Date.now(),\n        responseTime: Date.now() - startTime,\n        details: { checks, dependencies },\n        uptime: process.uptime(),\n        version: '1.0.0',\n      };\n      \n    } catch (error) {\n      return this.createUnhealthyStatus('ai-models', error.message);\n    }\n  }\n\n  private async checkWorkspaceHealth(): Promise<HealthStatus> {\n    const startTime = Date.now();\n    const checks: HealthCheck[] = [];\n    const dependencies: DependencyStatus[] = [];\n\n    try {\n      // Check workspace count\n      const workspaceKeys = await this.redis.keys('workspace:*');\n      \n      checks.push({\n        name: 'workspace_count',\n        status: 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `${workspaceKeys.length} workspaces active`,\n        metadata: { workspaceCount: workspaceKeys.length },\n      });\n\n      // Check knowledge graph health\n      const knowledgeKeys = await this.redis.keys('knowledge:*');\n      \n      checks.push({\n        name: 'knowledge_graph',\n        status: 'pass',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `${knowledgeKeys.length} knowledge nodes`,\n        metadata: { knowledgeNodeCount: knowledgeKeys.length },\n      });\n\n      const overallStatus = this.determineOverallStatus(checks);\n      \n      return {\n        service: 'workspace',\n        status: overallStatus,\n        lastCheck: Date.now(),\n        responseTime: Date.now() - startTime,\n        details: { checks, dependencies },\n        uptime: process.uptime(),\n        version: '1.0.0',\n      };\n      \n    } catch (error) {\n      return this.createUnhealthyStatus('workspace', error.message);\n    }\n  }\n\n  private async checkMonitoringHealth(): Promise<HealthStatus> {\n    const startTime = Date.now();\n    const checks: HealthCheck[] = [];\n    const dependencies: DependencyStatus[] = [];\n\n    try {\n      // Check metrics collection\n      const metricsKeys = await this.redis.keys('metrics:*');\n      \n      checks.push({\n        name: 'metrics_collection',\n        status: metricsKeys.length > 0 ? 'pass' : 'warn',\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `${metricsKeys.length} metric series active`,\n        metadata: { metricSeriesCount: metricsKeys.length },\n      });\n\n      // Check health check frequency\n      const lastHealthCheck = await this.redis.get('health:last_check');\n      const timeSinceLastCheck = lastHealthCheck ? Date.now() - parseInt(lastHealthCheck) : 0;\n      \n      checks.push({\n        name: 'health_check_frequency',\n        status: timeSinceLastCheck > 300000 ? 'fail' : timeSinceLastCheck > 120000 ? 'warn' : 'pass', // 5min/2min thresholds\n        duration: Date.now() - startTime,\n        timestamp: Date.now(),\n        message: `Last health check: ${Math.floor(timeSinceLastCheck / 1000)}s ago`,\n        metadata: { timeSinceLastCheck },\n      });\n\n      const overallStatus = this.determineOverallStatus(checks);\n      \n      return {\n        service: 'monitoring',\n        status: overallStatus,\n        lastCheck: Date.now(),\n        responseTime: Date.now() - startTime,\n        details: { checks, dependencies },\n        uptime: process.uptime(),\n        version: '1.0.0',\n      };\n      \n    } catch (error) {\n      return this.createUnhealthyStatus('monitoring', error.message);\n    }\n  }\n\n  private determineOverallStatus(checks: HealthCheck[]): HealthStatus['status'] {\n    const hasFailures = checks.some(check => check.status === 'fail');\n    const hasWarnings = checks.some(check => check.status === 'warn');\n    \n    if (hasFailures) return 'unhealthy';\n    if (hasWarnings) return 'degraded';\n    return 'healthy';\n  }\n\n  private createUnhealthyStatus(service: string, message: string): HealthStatus {\n    return {\n      service,\n      status: 'unhealthy',\n      lastCheck: Date.now(),\n      responseTime: 0,\n      details: {\n        checks: [{\n          name: 'error',\n          status: 'fail',\n          duration: 0,\n          timestamp: Date.now(),\n          message,\n        }],\n        dependencies: [],\n      },\n      uptime: 0,\n      version: 'unknown',\n    };\n  }\n\n  private parseRedisInfo(info: string, key: string): number | string | null {\n    const lines = info.split('\\r\\n');\n    for (const line of lines) {\n      if (line.startsWith(`${key}:`)) {\n        const value = line.split(':')[1];\n        const numValue = parseFloat(value);\n        return isNaN(numValue) ? value : numValue;\n      }\n    }\n    return null;\n  }\n\n  private async storeHealthStatus(healthResults: HealthStatus[]): Promise<void> {\n    try {\n      const healthData = {\n        timestamp: Date.now(),\n        services: healthResults.reduce((acc, health) => {\n          acc[health.service] = health;\n          return acc;\n        }, {} as Record<string, HealthStatus>),\n        overallStatus: this.calculateOverallHealth(healthResults),\n      };\n      \n      await this.redis.setex('health:current', 300, JSON.stringify(healthData)); // 5 minutes\n      await this.redis.set('health:last_check', Date.now().toString());\n      \n    } catch (error) {\n      logger.error('Failed to store health status:', error);\n    }\n  }\n\n  private calculateOverallHealth(healthResults: HealthStatus[]): HealthStatus['status'] {\n    const statuses = healthResults.map(h => h.status);\n    \n    if (statuses.includes('unhealthy')) return 'unhealthy';\n    if (statuses.includes('degraded')) return 'degraded';\n    if (statuses.includes('unknown')) return 'unknown';\n    return 'healthy';\n  }\n\n  public async getHealthStatus(service?: string): Promise<HealthStatus | HealthStatus[] | null> {\n    try {\n      if (service) {\n        return this.healthCache.get(service) || null;\n      }\n      \n      const healthData = await this.redis.get('health:current');\n      if (healthData) {\n        const parsed = JSON.parse(healthData);\n        return Object.values(parsed.services) as HealthStatus[];\n      }\n      \n      return Array.from(this.healthCache.values());\n      \n    } catch (error) {\n      logger.error('Failed to get health status:', error);\n      return null;\n    }\n  }\n\n  public async stop(): Promise<void> {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n    \n    logger.info('Health checks stopped');\n  }\n}\n"
//# sourceMappingURL=health-checker.js.map